# Протокол HTTP
### Структура HTTP
HTTP запросы и ответы имеют близкую структуру. Они состоят из:
+ Стартовой строки, описывающей запрос, или статус (успех или сбой). Это всегда одна строка.
+ Произвольного набора HTTP заголовков, определяющих запрос или описывающих тело сообщения.
+ Пустой строки, указывающей, что вся мета информация отправлена.
+ Произвольного тела, содержащего пересылаемые с запросом данные (например, содержимое HTML-формы) или отправляемый в ответ документ. Наличие тела и его размер определяется стартовой строкой и заголовками HTTP.

![http.jpg](resources/http.jpg)

### GET для безопасных действий, POST для опасных
GET-запросы лучше не использовать с приватной информацией, потому что:

+ Они кэшируются. Это значит, что логин и пароль, переданные через GET-запрос, могут остаться в интернете навсегда, например, в веб-архиве или кэше Гугла.
+ Остаются в истории браузера. Чтобы узнать, какие данные отправлялись, достаточно нажать Ctrl+H.
+ Сохраняются в закладках и пересылаются. Можно не обратить внимания и опубликовать в соцсетях или отправить ссылку с приватной информацией в GET-запросе.
+ Сохраняются в логах сервера. Например, нельзя отправлять данные банковских карт через GET-запрос, так как это создаёт риски для пользователей.

Таким образом, любые важные данные — логины, пароли, данные карты, персональные данные — лучше передавать с помощью метода POST, т.к. данные будут в body запроса и они не видны пользователю. Также метод POST поддерживает тип кодирования данных multipart/form-data, что позволяет передавать файлы.

### Методы
#### GET
+ Идемпотентный - сервер должен возвращать идентичные ответы на идентичные GET-запросы (при условии, что ресурс не изменился)
+ Не должен изменять данные на сервере
+ Данные передаются в урле
+ Доступно кеширование через заголовок Cache-control
+ Можно установить срок свежести кеша через max-age

#### POST
+ Предназначен для отправки данных на сервер.
+ Не идемпотентный - повторные запросы вызывают side-effect (создание новых сущностей)
+ Должен иметь тело - данные отправляются в теле
+ Тип тела запроса указывается в заголовке Content-Type.
+ Запрос POST обычно отправляется через форму HTML и приводит к изменению на сервере. 
+ Стандартный тип тела: 
    ```application/x-www-form-urlencoded```: значения кодируются в кортежах с ключом, разделенных символом '&', с '=' между ключом и значением. 
    + Не буквенно-цифровые символы - percent encoded: это причина, по которой этот тип не подходит для использования с двоичными данными

#### PUT
+ Заменяет ресурс если он существует или создает новый если его не было
+ Разница между PUT и POST состоит в том, что PUT является идемпотентным: 
повторное его применение дает тот же результат, что и при первом применении (то есть у метода нет побочных эффектов)
+ Тогда как повторный вызов одного и того же метода POST может иметь такие эффекты, 
как например, оформление одного и того же заказа несколько раз.
+ Пример:
  + До запроса PUT, GET http://localhost/cars:
    ```json
    {"id": 1, "name": "Mazda", "year": 2001}
    ```
  + Содержимое запроса PUT http://localhost/cars/1:
    ```json
    {"year": 2022}
    ```
  + После запроса PUT, GET http://localhost/cars:
    ```json
    {"id": 1, "year": 2022}
    ```
  + Т.е. PUT требует полного дублирования всех полей объекта вместе с измененным: непродублированные поля будут затерты

#### PATCH
+ Частично обновляет ресурс если он существует или возвращает ошибку если нет
+ Пример:
  + До запроса PATCH, GET http://localhost/cars:
    ```json
    {"id": 1, "name": "Mazda", "year": 2001}
    ```
  + Содержимое запроса PATCH http://localhost/cars/1:
    ```json
    {"year": 2022}
    ```
  + После запроса PATCH, GET http://localhost/cars:
    ```json
    {"id": 1, "name": "Mazda", "year": 2022}
    ```
  + Т.е. PATCH предоставляет возможность отправить несколько полей, чтобы произвести слияние

#### HEAD
+ То же что и GET, но не содержит тела ответа
+ Используется, например, для получения метаинформации о GET запросе

#### OPTIONS
+ Используется для описания параметров соединения с целевым ресурсом
+ Ответ на запрос OPTIONS может содержать список допустимых методов для данного ресурса в хедере Allow

#### CONNECT
+ Запускает двустороннюю связь с запрошенным ресурсом. 
+ Метод можно использовать для открытия туннеля

### Коды ответов
+ 1хх - информационные
+ 2хх - успешные
+ 3хх - редиректы
+ 4хх - клиентские ошибки (404 - не найден ресурс, 403 - сервер понял запрос но отказался обработать, 401 - unauthorized)
+ 5хх - серверные ошибки

### TLS (HTTPS)
HTTPS - это протокол защищённого соединения. В нем используется протокол TLS (Transport Layer Security). Он основан на 2х типах шифрования: 
+ [Ассиметричное](algorithms.md#шифрование) - публичный ключ отсылается клиенту (в TLS-сертификате, см [ниже](#алгоритм-соединения-по-https-с-учетом-сертификатов)), приватный ключ хранится на сервере (предоставляется от Certificate Authority или может быть сгенерирован самостоятельно - тогда сертификат считается самоподписанным). Используется только для установления соединения и открытия сессии
+ [Симметричное](algorithms.md#шифрование) - один ключ, генерируется клиентом и отправляется серверу шифруясь публичным ключом. Используется для обмена сообщениями в сессии

#### Алгоритм соединения по HTTPS упрощенно
+ Вы связываетесь с сервером по открытому каналу и просите его установить с вами защищённое соединение
+ Сервер отправляет вам свой открытый ключ (в TLS-сертификате, см [ниже](#алгоритм-соединения-по-https-с-учетом-сертификатов)), вы генерируете ключ симметричного шифрования, для использования только в этом соединении (сессионный ключ) 
+ Шифруете этот ключ открытым ключом сервера и отправляете его на сервер. Никто, кроме сервера, не сможет прочитать этот сессионный ключ
+ Сервер расшифровывает это сообщение своим закрытым ключом, и получает сессионный ключ, сгенерированный вами
+ С этого момента вы можете обмениваться зашифрованными сообщениями с сервером, используя симметричное шифрование с этим сессионным ключом

#### Инфраструктура открытых ключей и TLS-сертификатов
Эта система основана на механизме, который можно назвать цепочкой доверия. 

У каждого пользователя Интернета есть список организаций, которым он безусловно доверяет. 

Открытые ключи шифрования этих организаций хранятся на его устройстве, и он считает, что эти ключи подлинные, а не подделанные с помощью атаки «Man In The Middle» (перехватывает открытый ключ от сервера и вместо него отправит вам свой открытый ключ). 
Такие доверенные организации называются сертификационными центрами (Certificate Authority, или CA). 
Их открытые ключи предустановлены в операционную систему пользователя, что и даёт ему основания верить в их подлинность. 

Задача таких организаций — выдавать TLS-сертификаты владельцам сайтов. Сертификат — это электронный документ, который удостоверяет, что данный открытый ключ действительно принадлежит данному сайту (по крайней мере, за это ручается данный сертификационный центр).
Благодаря этому, «человек посередине» сможет подделать открытый ключ сервера не раньше, чем он сумеет подделать сертификат. 
Для рядового интернет-мошенника подделать такой сертификат не представляется возможным, поскольку приватные ключи CA слишком хорошо охраняются.

Файл сертификата содержит название CA, выдавшего сертификат, открытый ключ сервера, название сервера (например, доменное имя), названия алгоритмов шифрования и хэширования, срок действия, серийный номер и цифровую подпись. 
Сервер, для которого выпущен сертификат, также получает приватный ключ.
Технология цифровой подписи основана на технологии асимметричного шифрования

#### Алгоритм соединения по HTTPS с учетом сертификатов
+ Клиент владеет данными сертификационного центра, которому он доверяет. У него есть открытый ключ этого сертификационного центра. 
+ Сервер присылает клиенту сертификат, подписанный электронной подписью этого CA. 
+ С помощью открытого ключа CA клиент проверяет, что цифровая подпись подлинная, и что данный сертификат действительно подписан этим сертификационным центром. Это означает, что сертификат пришёл от сервера, а не от «человека посередине». 
+ Далее открытый ключ сервера используется для согласования сессионного ключа. 
+ Это может происходить по описанному выше алгоритму обмена сессионными ключами используя симметричное шифрование, но фактически процесс сложнее, используется алгоритм Диффи-Хеллмана (позволяет сохранить конфиденциальность прошлых сессий, даже если приватный ключ сервера в будущем будет скомпрометирован).

Подробная статья - https://habr.com/ru/articles/840116/
