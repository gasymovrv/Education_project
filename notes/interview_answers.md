### Самопрезентация 5 минут о себе:
1. Приветствие/Должность/Направление работы
3. Опыт более 2х лет, участвовал примерно в 5 проектах
4. Проекты на которых я работал (последние 2)
5. Описание проекта (создавались с нуля!), какие технологии применялись
6. Роль в проекте / Состав команды
7. Методология разработки (скрам, канбан)

# Ответы на типичные вопросы собеседования с Java-разработчиком
### Методы Object
1. `int hashCode()` - возвращает хеш-код объекта
1. `boolean equals(Object obj)` - определяет, равен ли текущий объект другому
1. `Object clone()` - клонирует объект
1. `void finalize()` - вызывается перед удалением неиспользуемого объекта
1. `Class<?> getClass()` - получает класс объекта во время выполнения
1. `void notify()` - возобновляет выполнение потока, который ожидает вызывающего объекта
1. `void notifyAll()` - возобновляет выполнение всех потоков, которые ожидают вызывающего объекта
1. `String toString()` - возвращает строку, описывающую объект
1. `void wait()` - ожидает другого потока выполнения (есть перегрузки с параметром времени ожидания)

### Правила реализации equals/hashCode
+ `equals`:
    + Рефлексивность: Объект должен равняться себе самому.
    + Симметричность: если `a.equals(b) == true`, то `b.equals(a)` должен тоже быть `true`.
    + Транзитивность: если `a.equals(b) == true` и `b.equals(c) == true`, то `c.equals(a)` тоже должен быть `true`.
    + Согласованность: повторный вызов метода `equals()` должен возвращать одно и тоже значение, пока какое-либо значение свойств объекта не будет изменено
    + Сравнение с `null`: `a.equals(null)` должен вернуть `false`, а не NPE.
+ `hashcode`:
    + Должен использовать для вычисления те же поля что и `equals()`
    + У двух одинаковых объектов `hashcode` ДОЛЖЕН быть одинаковым
    + У двух разных объектов `hashcode` МОЖЕТ быть одинаковым (это коллизия, лучше чтобы такого не было)

### Сложности коллекций
+ ArrayList
    + лучшее O(1) - чтения из любого места (прямой доступ к памяти через массив) и вставка в конец;
    + худшее O(n) - вставка - будет тем хуже чем ближе к началу, т.к. придется копировать больше элементов. Например если вставлять в середину то будет O(n/2)

+ LinkedList
    + лучшее O(1) - все операции с первым/последним элементом;
    + худшее O(n) - все операции с элементом в середине, т.к. придется делать обход в цикле

+ HashMap/HashSet
    + лучшее O(1) - все операции, если коллизий нет и вставка даже если коллизий много, т.к. всегда вставляется в начало корзины (связного списка);
    + худшее O(log(n)) - чтение, если у всех элементов одинаковый hashCode - начиная с Java 8 после достижения определенного порога размера корзины вместо связанных списков используются сбалансированные деревья (до этого было O(n))
    
+ LinkedHashMap/LinkedHashSet
    + O(1)/O(log(n)) - так же как и у HashMap, но чуть больше памяти на хранение связей;
        
+ TreeMap/TreeSet
    + гарантировано не хуже O(log(n)) - все операции, т.к. красно-черное дерево гарантирует такую сложность в худшем случае

+ Пояснения о работе HashMap   
	+ HashMap представляет из себя массив связных списков (корзин), дефолтный length которого = 16.
	+ Индекс вставки рассчитывается как ((length-1) & hash) - так всегда получается число в дипазаоне изначального length.
	    + где hash - это особый хеш из реализации HashMap на основе hashCode вставляемого ключа - гарантирует что коллизий будет не более 8 (элементов связного списка) с дефолтным capacity/loadfactor и правильным hashCode

	+ **put**:
	    + Вычислили индекс вставки
	    + Нашли корзину по этому индексу (если ее нет, то создали новую с этим элементом и на этом заканчиваем)
	    + Поочередно сравниваем хэши вставляемого элемента с хэшами элементов из корзины и если:
	    	+ Они идентичны. Далее проверяется equals:
	    	    + equals == true - значение элемента перезаписывается.
	    	    + equals == false - элемент добавялется в текущую корзину как новый элемент
	    	+ Они НЕ идентичны. Элемент добавялется в текущую корзину как новый элемент

	+ **get**:
        + Вычислили индекс вставки
        + Нашли корзину по этому индексу (если ее нет, то возвращаем NULL)
        + Поочередно сравниваем хэши искомого элемента с хэшами элементов из корзины и если:
            + Они идентичны. Далее проверяется equals:
                + equals == true - возвращаем ЭЛЕМЕНТ.
                + equals == false, то возвращаем NULL

    + Чем больше корзин, тем меньше коллизий - меньше итераций внутри корзин, но больше памяти потребуется (когда loadFactor меньше) 
    + Чем меньше корзин, тем больше коллизий - меньше памяти, но больше итераций при поиске. (когда loadFactor больше)

### Синтаксис Java
+ Наследование
+ Множественное насл-ие - в Java оно есть только для интерфейсов, что избавляет от проблемы совпадения имен методов
    + Совпадение имен методов в интерфейсах не приводит к проблемам, т.к. реализации они еще не имеют
    + Если совпадение имен произойдет с дефолтными методами, то программа не скомпилируется
+ Перегрузка - возвращаемые типы могут отлчиаться - это разные методы
+ Переопределение - возвращаемые типы могут сужаться, но не расширяться

### JVM компоненты:
+ Classloader - загрузка классов из classpath
+ Garbage Collector - автоматическое управление памятью - heap
+ JIT-компилятор - динамическая компиляция байт кода в машинный код
+ компоненты управления потоками
+ и др.

+ Типы памяти
    + heap - хранятся объекты, чистится GC, общий на все приложение;
    + stack - хранятся локальные примитивы в методах и ссылки на объекты, чистится при завершении метода, потокобезопасен (отдельный стек на каждый поток)

### SOLID примеры нарушения принципов
+ S - single responsibility
    + Первый признак нарушения - если при изменении кода, отвечающего за одну ответственность, появляются исправления кода, отвечающего за другую ответственность
+ O - open/closed
    + открыты для расширения: поведение сущности может быть расширено путём создания новых типов сущностей.
    + закрыты для изменения: при расширении не должны вноситься изменения в код, который эти сущности использует.
+ L - Liskov
    + Дочерние классы можно использовать через интерфейсы базовых классов (в Java это нельзя нарушить)
+ I - interface
    + Слишком «толстые» интерфейсы и клиентам приходится реализовывать много лишних методов
+ D - dependency inversion 
    + Все должно зависеть от абстракций, а не от деталей, нарушаем например если инжектим не интерфейс а реализацию
+ Подробнее тут: [SOLID](OOP.md)

### Паттерны и их применения в JDK
+ Прототип – `Cloneable`
+ Адаптер – `InputStreamReader`, `OutputStreamWriter` и др.
+ Декоратор – все подклассы `java.io.InputStream`, `OutputStream`, `Reader` и `Writer` имеют конструктор, принимающий объекты этих же классов
+ Прокси - все бины Spring или EJB
+ Итератор – `java.util.Iterator` + внутренняя реализация его в коллекциях
+ Шаблонный метод - сервлеты (метод `service()`)
+ Легковес - `java.lang.Integer#valueOf(int)` – если значение есть в кэше (IntegerCache – от -128 до 127) то возвращет его, иначе новый объект (а также `Boolean`, `Byte`, `Character`, `Short`, `Long` и `BigDecimal`)
+ Посетитель - `java.nio.file.FileVisitor` 
+ Стратегия - `java.util.Comparator#compare()`, вызываемые из `Collections#sort(List, Comparator)`
+ Строитель – `StringBuilder`, `Appendable`  и др.
+ Цепочка обязанностей - `javax.servlet.Filter#doFilter()`
+ Фабричный метод - `java.util.EnumSet#of()`, `java.util.List#of()`

### Spring
+ Подробнее [тут](java/spring.md)

### AOP/aspectj
+ AOP - аспекты используемые в Spring. 
    + Они могут юзать для создания прокси как jdk-dymanic (если у нашего класса есть интерфейс) так и cglib (если нтерфейса нет то прокси создастся с помощью наследования)
	+ В каком потоке вызывается аспект? - по умолчанию в том же, но можно настроить
+ AspectJ - аспекты которые создаются на этапе компиляции и не требуют паттернов в коде. Сложнее но быстрее

### Кэш
+ Использовать когда много операций чтения, но мало изменений, 
+ Даст быстрое чтение но больше памяти, 
+ Появляется проблема устаревших данные - evicting кэша
	+ В hibernate реашется несколькими стратегиями обновления кеша:
		+ `read only` - Изменение данных при использовании этой стратегии приведёт к исключению.
		+ `nonstrict read write` - доступ для изменений не ограничивается и есть вероятность чтения устаревших
		+ `read write` - чтение из кеша блокируется (запрос идет в БД) при измении данных в данный момент

### Транзакции, ACID
+ Atomicity — Атомарность
    + Должны быть выполнены либо все её подоперации, либо не выполнено ни одной
+ Consistency — Согласованность
    + Каждая успешная транзакция по определению фиксирует только допустимые результаты
+ Isolation — Изолированность
    + Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат
+ Durability — Стойкость
    + Изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу

+ Пример не согласованности данных - отрицательный возраст

+ Проблемы плохой изолированности (параллельного доступа, где 1 - 1ая транзакция, 2 - 2ая):
	+ Потерянное обновление (1:update(+=) + 2:update(+=))
	+ «Грязное» чтение (1:update/insert + 2:select + 1:rollback)
	+ Неповторяющееся чтение (1:select + 2:update/delete + 1:select)
	+ Чтение «фантомов» (1:select + 2:insert + 1:select)
	
	+ Решения этих проблем специальными [уровнями изоляции в БД](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9):

        | Уровень изоляции | Фантомное чтение | Неповторяющееся чтение | «Грязное» чтение | Потерянное обновление |
        |:----------------:|:----------------:|:----------------------:|:----------------:|:---------------------:|
        | READ UNCOMMITTED |         -        |            -           |         -        |           +           |
        |  READ COMMITTED  |         -        |            -           |         +        |           +           |
        |  REPEATABLE READ |         -        |            +           |         +        |           +           |
        |   SERIALIZABLE   |         +        |            +           |         +        |           +           |

### SQL 
+ select
+ insert
+ update
+ delete
+ join (inner, outer left, outer right)
+ union
+ Группировка по месяцам из дат (для postgres функция EXTRACT)

### Высоконагруженнные сервисы
+ Масштабирование (модульные монолиты, микросервисы)
+ Микросервисы должны быть stateless, т.к. stateful приложение масштабировать очень сложно
+ Обмен сообщениями/распределенные транзакции - связь между микросервисами обычно организуют через брокеры сообщений
+ Репликации и шардирование БД, но лучше чтобы у каждого сервиса была своя БД
+ Переход на реактивщину - позволит ускорить работу сервиса

### Web services
##### REST
+ работает только по http, 
+ данные в любом формате (чаще json), 
+ операции клиента с сервером stateless, CRUD. 
+ легче соапа. хорошо подходит когда нужно работать с фронтом

##### SOAP
+ работает по любому протоколу, 
+ данные только в xml. 
+ имеет строгий стандарт. 
+ Лучше подходит для сервер - сервер, считается более безопасным
+ wsdl - язык описания веб-сервисов и доступа к ним, основанный на языке XML. Основные элементы:
	+ types — типы XML-сообщений (xsd схемы, парсятся в классы)
	+ message — сообщения, используемые web-сервисом (связь операций с типами-классами)
	+ portType — список операций, которые могут быть выполнены с сообщениями (методы, будут ожидаться в теле запросов)
	+ binding — способ, которым сообщение будет доставлено (протокол и др.)
	+ service - это набор ендпойнтов
	+ помоему есть еще что-то связанное с шифрованием (signature, security ...)

### HTTP
+ GET
	+ идемпотентный - 1 и тот же результат при повторных запросах, не должен изменять данные на сервере, данные передаются в урле
	+ Доступно кеширование через заголовок Cache-control
	+ можно установить срок свежести кеша через max-age
+ POST 
	+ Не идемпотентный - повторные запросы вызывают side-effect (создание новых сущностей), данные отправляются в теле
+ OPTIONS
	+ Ответ на запрос OPTIONS может содержать список допустимых методов для данного ресурса в хедере Allow
+ Коды ответов
	+ 1хх - информационные
	+ 2хх - успешные
	+ 3хх - редиректы
	+ 4хх - клиентские (404 - не найден ресурс, 403 - сервер понял запрос но отказался обработать, 401 - unauthorized)
	+ 5хх - серверные	