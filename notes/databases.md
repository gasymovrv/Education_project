# Базы данных

### Транзакции и ACID

#### Atomicity — Атомарность
+ Должны быть выполнены либо все её подоперации, либо не выполнено ни одной

#### Consistency — Согласованность
+ Каждая успешная транзакция по определению фиксирует только допустимые результаты
+ Пример не согласованности данных - отрицательный возраст, отрицательный баланс на счете

#### Isolation — Изолированность
+ Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат
+ Проблемы плохой изолированности (параллельного доступа, где 1 - 1ая транзакция, 2 - 2ая):
	+ Потерянное обновление (1:update(+=) + 2:update(+=))
	+ «Грязное» чтение (1:update/insert + 2:select + 1:rollback)
	+ Неповторяющееся чтение (1:select + 2:update/delete + 1:select)
	+ Чтение «фантомов» (1:select + 2:insert + 1:select)
	
	+ Решения этих проблем специальными [уровнями изоляции в БД](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9):

        | Уровень изоляции | Фантомное чтение | Неповторяющееся чтение | «Грязное» чтение | Потерянное обновление |
        |:----------------:|:----------------:|:----------------------:|:----------------:|:---------------------:|
        | READ UNCOMMITTED |         -        |            -           |         -        |           +           |
        |  READ COMMITTED  |         -        |            -           |         +        |           +           |
        |  REPEATABLE READ |         -        |            +           |         +        |           +           |
        |   SERIALIZABLE   |         +        |            +           |         +        |           +           |
        
#### Durability — Стойкость
+ Изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу

### Теорема CAP
+ Утверждение о том, что в любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств:
    + согласованность (consistency) — во всех вычислительных узлах в один момент времени данные не противоречат друг другу;
    + доступность (availability) — любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают;
    + устойчивость к разрывам сети (partition tolerance) — устойчивость к распределению. Даже если между узлами нет связи, они продолжают работать независимо друг от друга.
+ Подробнее [тут](https://habr.com/ru/post/328792/)

## SQL
### Синтаксис 
+ select
+ insert
+ update
+ delete
+ join (inner, outer left, outer right)
+ union
+ Группировка по месяцам из дат (для postgres функция EXTRACT)
+ Решения задач с http://sql-ex.ru
    + [src/main/resources/db](/src/main/resources/db)

### Нормализация и денормализация
+ Нормализация - устранение аномалий и избыточности данных (приведение таблиц к нормальным формам)
    + *1F*. 1 столбец – 1 значение. Т.е. столбцы со значениями типа `Иванов И.И., зам. дир., тел. +7123456789` должны быть разделены на несколько
    + *2F*. Есть первичный ключ или, если он составной, то все столбцы от него зависят. Иначе составной ключ нужно разбивать на простой и выносить зависимые столбцы в отдельную таблицу
    + *3F*. Не должно быть вычисляемых или зависимых друг от друга (а не от первичного ключа) столбцов. Такие столбцы выносим в отдельную таблицу
+ Денормализация - отклонение от требований НФ с целью повысить быстродействие и снизить сложность схемы БД

### Индексы
+ Индексы - это структура хранящая упорядоченные ссылки на записи в индексируемом столбце в виде сбалансированных деревьев
    + Главная цель - ускорить запросы на получение данных (SELECT)
    + Немного замедляет процесс добавления и изменения записей (INSERT, UPDATE), т.к. значения в индексе необходимо обновить после добавления/изменения/удаления записей. 
    + Составной индекс, как правило, может использоваться для запросов по первому столбцу этого индекса. Разумное создание индексов может сократить их количество.
    + Индекс занимает место на диске, т.к. хранит данные своего столбца и ROWID (ссылки)
    + Рекомендации:
        + Если по столбцу часто производится поиск (WHERE), то для него лучше создать индекс
        + С табличным столбцом, по которому проводится сортировка данных и который обычно указывается в предложении order by, необходимо связать индекс, чтобы SQL Сервер мог проводить упорядочение значений по этому индексу
        + Столбцы, по которым часто проводится соединение таблиц, всегда должны индексироваться, поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение происходит значительно быстрее
        + Столбцы, которые содержат всего два или три значения, например, мужской, женский пол или значения “да”, “нет”, не стоит индексировать

+ Кластерные индексы - сохраняют данные записей целиком, а не ссылки на них. Может быть только один, т.к. изменяет (упорядочивает) структуру таблицы и данные таблицы становится частью такого индекса. В postgresql кластеризация является одноразовой операцией: последующие изменения в таблице нарушают порядок кластеризации.

### PostgreSQL
+ Первичный ключ - PostgreSQL автоматически создает индекс для каждого уникального ограничения и ограничения первичного ключа для обеспечения уникальности.
+ Когда использовать неструктурированные типы данных (JSON/JSONB/Hstore)?
    + JSONB — В большинстве случаев когда нужно NoSql (то есть мы не можем описать схему данных). Пример:
        ```postgresql
        CREATE TABLE integrations (id UUID, data JSONB);
    
        INSERT INTO integrations VALUES (
            uuid_generate_v4(),
            '{
                "service": "salesforce",
                "id": "AC347D212341XR",
                "email": "craig@citusdata.com",
                "occurred_at": "8/14/16 11:00:00",
                "added": {
                    "lead_score": 50
                },
                "updated": {
                    "updated_at": "8/14/16 11:00:00"
                }
           }');
        ```
    + JSON — Если вы обрабатываете логи, вам не часто приходится запрашивать данные или не нужно использовать их как что-то большее чем для задач логирования.
    + Hstore — отлично работает с текстовыми данными на основе представления ключ-значение, но в целом JSONB также отлично справляется с этой задачей.
    + Подробнее [тут](https://habr.com/ru/post/306602/)
+ Типы индексов в PostgreSQL
    + B-дерево - по умолчанию команда CREATE INDEX создаёт индексы этого типа, эффективные в большинстве случаев
        + Используется когда индексируемый столбец участвует в сравнении с одним из следующих операторов: 
            + `<`,`<=`,`=`,`>=`,`>`
            + `BETWEEN`, `IN`
            + `IS NULL`, `IS NOT NULL`
            + Может использоваться при сравнении по шаблону LIKE и ~, если этот шаблон определяется константой и он привязан к началу строки — например, `col LIKE 'foo%'` или `col ~ '^foo'`, но НЕ `col LIKE '%bar'`
    + Хеш - Планировщик запросов может применить хеш-индекс, только если индексируемый столбец участвует в сравнении с оператором `=`.
        + Пример: `CREATE INDEX имя ON таблица USING HASH (столбец);`
    + GIN - Создание индекса GIN на колонке JSONB создаст индекс по каждому ключу и значению (даже вложенным) в пределах этого документа JSON
    + GiST, SP-GiST - представляют собой не просто разновидность индексов, а инфраструктуру, позволяющую реализовать много разных стратегий индексирования.
    + BRIN - сокращение от Block Range INdexes, Индексы зон блоков. Хранят обобщённые сведения о значениях, находящихся в физически последовательно расположенных блоках таблицы
+ Пример рекурсивного запроса:
    ```postgresql
    CREATE TABLE geo (
        id int not null primary key,
        parent_id int references geo(id),
        name varchar(1000)
    );
    
    INSERT INTO geo
    (id, parent_id, name)
    VALUES
    (1, null, 'Планета Земля'),
    (2, 1, 'Континент Евразия'),
    (3, 1, 'Континент Северная Америка'),
    (4, 2, 'Европа'),
    (5, 4, 'Россия'),
    (6, 4, 'Германия'),
    (7, 5, 'Москва'),
    (8, 5, 'Санкт-Петербург'),
    (9, 6, 'Берлин');
    
    EXPLAIN WITH RECURSIVE r AS (
       SELECT id, parent_id, name
       FROM geo
       WHERE parent_id = 4
    
       UNION
    
       SELECT geo.id, geo.parent_id, geo.name
       FROM geo
       JOIN r ON geo.parent_id = r.id
    )
    SELECT * FROM r;
    ```

## NoSQL СУБД
+ Подробнее [тут](https://habr.com/ru/company/oleg-bunin/blog/319052/)

### Сравнение NoSQL с SQL
+ SQL (Structured Query Language) — универсальный язык запросов, который используется всеми реляционными системами.
+ NoSQL имеют собственный API для взаимодействия.
+ Преимущества РСУБД — соответствия базы данных требованиям ACID, целостность данных, структурированность.
+ Преимущества NoSQL — скорость обработки данных, масштабируемость, распределенность систем.
+ Подробнее [тут](https://habr.com/ru/sandbox/113232/)

#### Типы NoSql СУБД
+ Key/value хранилища
    + Хранение в виде ассоциативного массива. Минимальный интерфейс для такой базы данных состоит всего из 3-х операций — get, set и delete
    + Примеры
        + Memcashed
        + Redis (с натяжкой)
        + Riak
        
+ Документ-ориентированные базы данных
    + Это сильно усложненный вариант предыдущей категории. Эта добавленная сложность — она дает ещё и бонусы: теперь значения — это не какой-то непрозрачный текстовый блоб, с которым ничего нельзя делать, кроме того, что целиком прочитать или удалить, а теперь можно работать более тонко со значением. Если нам нужна только часть документа, можем ее прочитать или обновить только часть
    + Примеры
        + MongoDB 
        + CouchDB
        + ElasticSearch
    
+ Колоночные базы данных
    + Есть файл — в нем хранятся все поля данной колонки из всех N млрд. записей, хранятся все рядом. Соответственно, другая колонка хранится в другом файле. За счет этого они могут применять улучшенное сжатие за счет использования информации о типе данных колонки. Также это может ускорять запросы, если, нам, например, нужны 3 колонки из 300, то нам не обязательно грузить остальные 297.
    + Примеры
        + HBase
        + Cassandra
        + Vertica
        + ClickHouse
    
+ Графовые базы данных
    + Сила этих баз данных в том, что за счет своей специализации они могут эффективно выполнять всякие операции над графами, но также в силу той же специализации они не сильно распространены
    + Примеры
        + Neo4j
    
+ Мультимодельные базы данных
    + Это такие базы данных, в которые одновременно входит две или более категорий из предыдущих.
    + Примеры
        + FoundationDB
        + ArangoDB
        + OrientDB

