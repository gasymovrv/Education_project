# Базы данных

## Транзакции и ACID

#### Atomicity — Атомарность
+ Должны быть выполнены либо все её подоперации, либо не выполнено ни одной

#### Consistency — Согласованность
+ Каждая успешная транзакция по определению фиксирует только допустимые результаты
+ Пример не согласованности данных - отрицательный возраст, отрицательный баланс на счете

#### Isolation — Изолированность
+ Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат
+ Проблемы плохой изолированности (параллельного доступа, где 1 - 1ая транзакция, 2 - 2ая):
    + Потерянное обновление (1:update(+=) + 2:update(+=))
    + «Грязное» чтение (1:update/insert + 2:select + 1:rollback)
    + Неповторяющееся чтение (1:select + 2:update/delete + 1:select)
    + Чтение «фантомов» (1:select + 2:insert + 1:select)
	
    + Решения этих проблем специальными [уровнями изоляции в БД](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9):

| Уровень изоляции | Фантомное чтение | Неповторяющееся чтение | «Грязное» чтение | Потерянное обновление |
|:----------------:|:----------------:|:----------------------:|:----------------:|:---------------------:|
| READ UNCOMMITTED |         -        |            -           |         -        |           +           |
|  READ COMMITTED  |         -        |            -           |         +        |           +           |
|  REPEATABLE READ |         -        |            +           |         +        |           +           |
|   SERIALIZABLE   |         +        |            +           |         +        |           +           |

#### Durability — Стойкость
+ Изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения системы в работу

---

## Теорема CAP
Утверждение о том, что в любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств:
+ согласованность (consistency) — во всех вычислительных узлах в один момент времени данные не противоречат друг другу;
+ доступность (availability) — любой запрос к распределённой системе завершается корректным откликом, однако без гарантии, что ответы всех узлов системы совпадают;
+ устойчивость к разрывам сети (partition tolerance) — устойчивость к распределению. Даже если между узлами нет связи, они продолжают работать независимо друг от друга.

В распределённых базах данных различают три типа систем по теореме CAP: 
+ CP (консистентность и устойчивость к разделению при жертве доступности),
  + Пример — PostgreSQL в распределённом режиме с синхронной репликацией или MongoDB с настройками строгой консистентности: они блокируют операции при сбое узлов ради согласованности данных.
+ AP (доступность и устойчивость к разделению при жертве консистентности)
  + Пример AP-систем — Cassandra, DynamoDB, PostgreSQL с асинхронной репликацией, MongoDB: они продолжают обслуживать запросы даже при сетевых разделениях, но могут временно возвращать устаревшие данные.
+ теоретические CA (консистентность и доступность без устойчивости к разделению). В реальности сетевые разделения неизбежны, поэтому полноценные CA-системы возможны только в нераспределённых решениях (например, традиционные реляционные базы данных вроде Oracle или PostgreSQL в одиночном узле).

Подробнее [habr](https://habr.com/ru/post/328792/)

---

## SQL СУБД

### Синтаксис 
+ select
+ insert
+ update
+ delete
+ join (inner, outer left, outer right)
+ union
+ Группировка по месяцам из дат (для postgres функция EXTRACT)
+ Решения задач с http://sql-ex.ru
    + [_java_/src/main/resources/db](../_java_/src/main/resources/db)

---

### Нормализация и денормализация
+ Нормализация - устранение аномалий и избыточности данных (приведение таблиц к нормальным формам)
    + *1F*. 1 столбец – 1 значение. Т.е. столбцы со значениями типа `Иванов И.И., зам. дир., тел. +7123456789` должны быть разделены на несколько
    + *2F*. Есть первичный ключ или, если он составной, то все столбцы от него зависят. Иначе составной ключ нужно разбивать на простой и выносить зависимые столбцы в отдельную таблицу
    + *3F*. Не должно быть вычисляемых или зависимых друг от друга (а не от первичного ключа) столбцов. Такие столбцы выносим в отдельную таблицу
+ Денормализация - отклонение от требований НФ с целью повысить быстродействие и снизить сложность схемы БД

---

### Индексы
+ Индексы - это структура хранящая упорядоченные ссылки на записи в индексируемом столбце в виде сбалансированных деревьев
    + Главная цель - ускорить запросы на получение данных (SELECT)
    + Немного замедляет процесс добавления и изменения записей (INSERT, UPDATE), т.к. значения в индексе необходимо обновить после добавления/изменения/удаления записей. 
    + Составной индекс, как правило, может использоваться для запросов по первому столбцу этого индекса. Разумное создание индексов может сократить их количество.
    + Индекс занимает место на диске, т.к. хранит данные своего столбца и ROWID (ссылки)
    + Рекомендации:
        + Если по столбцу часто производится поиск (WHERE), то для него лучше создать индекс
        + С табличным столбцом, по которому проводится сортировка данных и который обычно указывается в предложении order by, необходимо связать индекс, чтобы SQL Сервер мог проводить упорядочение значений по этому индексу
        + Столбцы, по которым часто проводится соединение таблиц, всегда должны индексироваться, поскольку в этом случае данные располагаются в порядке возрастания индекса и соединение происходит значительно быстрее
        + Столбцы, которые содержат всего два или три значения, например, мужской, женский пол или значения “да”, “нет”, не стоит индексировать

+ Кластерные индексы - сохраняют данные записей целиком, а не ссылки на них. Может быть только один, т.к. изменяет (упорядочивает) структуру таблицы и данные таблицы становится частью такого индекса. В postgresql кластеризация является одноразовой операцией: последующие изменения в таблице нарушают порядок кластеризации.

---

### Партицирование
Партицирование – это метод разделения больших (исходя из количества записей, а не столбцов) таблиц на много маленьких по определенным критерием - например разбиение на партиции по годам (например столбец created_at).
+ Запросы при этом не надо переписывать/оптимизировать.
+ Поможет ускорить доступ если планируем много искать данные в таблице (и знаем что в WHERE большинства запросов будет участвовать партицируемый столбец) и при этом много изменять.

---

### PostgreSQL
Первичный ключ - PostgreSQL автоматически создает индекс для каждого уникального ограничения и ограничения первичного ключа для обеспечения уникальности.

#### Индексы в PostgreSQL
**Типы индексов:**
+ B-Tree - по умолчанию команда CREATE INDEX создаёт индексы этого типа, эффективные в большинстве случаев
    + Используется когда индексируемый столбец участвует в сравнении с одним из следующих операторов: 
        + `<`,`<=`,`=`,`>=`,`>`
        + `BETWEEN`, `IN`
        + `IS NULL`, `IS NOT NULL`
        + Может использоваться при сравнении по шаблону `LIKE` и `~` (регулярные выражения), если этот шаблон определяется константой и он привязан к началу строки — например, `col LIKE 'foo%'` или `col ~ '^foo'`, но НЕ `col LIKE '%bar'`
+ Hash — работает только в сравнении через оператор `=`.
    + Пример: `CREATE INDEX имя ON таблица USING HASH (столбец);`
+ GIN - быстрый поиск по множествам (JSONB, массивы, полнотекст, trigram).
+ GiST — обобщённый, для геоданных, диапазонов, ближайших соседей.
+ SP-GiST — деревья (trie, k-d), для разрежённых данных. 
+ BRIN — компактный индекс по диапазонам страниц, хорош для больших append-only таблиц.

**Что такое составной индекс и правило «левого префикса»?**
+ Индекс `(a,b,c)` ускоряет поиск:  
  - по `a`,  
  - по `(a,b)`,  
  - по `(a,b,c)`.
  - Но **не** по `b` без условия на `a`.

**Что такое частичный индекс?**  
+ Индекс, построенный только на подмножестве строк:  
    ```sql
    CREATE INDEX ON orders (status) WHERE status = 'NEW';
    ```  
+ Уменьшает размер, ускоряет «типовые» запросы.

**Что такое покрывающий индекс (index-only scan)?**  
+ Если индекс содержит все столбцы запроса, чтение таблицы не требуется.  
+ В PostgreSQL это возможно при:  
  - наличии всех колонок в индексе (через `INCLUDE`),  
  - актуальной **Visibility Map** (нужен `VACUUM`).  

**Что такое `pg_trgm` и зачем оно нужно?**  
+ Расширение для поиска по триграммам (подстроки длиной 3 символа).
+ Примеры:  
    ```sql
    CREATE EXTENSION pg_trgm;
    CREATE INDEX ON docs USING gin (content gin_trgm_ops);
    SELECT * FROM docs WHERE content ILIKE '%postgres%';
    ```
+ Поддерживает:  
  - ускорение `LIKE`, `ILIKE`, `~`,  
  - функции `similarity()`,  
  - оператор `%` (схожесть > порога).  

---

#### Полнотекстовый поиск в PostgreSQL
Подробное видео о полнотекстовом поиске: [youtube](https://habr.com/ru/post/306602/)

И материалы из видео локально: <a href = "file:///D:/Education/Databases/Postgres-lessons">Postgres-lessons</a>

Основные концепции:
- Документы: Текстовые данные, преобразованные в специальный тип `tsvector`, оптимизированный для поиска.
- Запросы: Поисковые входные данные, представленные в виде типа `tsquery`, с использованием логических операторов (например, `&`, `|`, `!`, `<->`).
- Релевантность: Оценка качества совпадения при помощи функций, таких как `ts_rank` и `ts_rank_cd`.

Основные команды:
- Базовый поиск: 
  ```sql
  SELECT * FROM table WHERE to_tsvector(column) @@ to_tsquery('query');
  ```
- Фразовый поиск:
  ```sql
  to_tsquery('слово1 <-> слово2');  -- Находит слово1, за которым следует слово2.
  ```
- Ранжирование результатов:
  ```sql
  SELECT ts_rank(to_tsvector(column), to_tsquery('query')) AS rank;
  ```

Конфигурация и обработка текста:
- Обработка текста: Документ → Анализатор → Токен → Словарь → Лексема.
- Анализаторы: Разбивают текст на токены (например, слова, числа, URL).
  - Встроенный анализатор: `pg_catalog.default`.
- Словари: Нормализуют токены (например, приводят к нижнему регистру, выполняют стемминг или удаляют стоп-слова).
  - Примеры словарей: 
    - `simple` — базовые преобразования.
    - `snowball` — стемминг (приведения слов к их базовой или корневой форме для учета различных словоформ при поиске) для различных языков.
    - `unaccent` — удаляет диакритические знаки.
- Конфигурации: Связывают анализаторы и цепочки словарей для различных типов токенов.
  - Конфигурация по умолчанию: `pg_catalog.english`.
  - Настройка цепочек словарей для токенов:
    ```sql
    ALTER TEXT SEARCH CONFIGURATION english
    ALTER MAPPING FOR word WITH unaccent, english_stem;
    ```

Индексация
- Типы индексов:
  - GIN (Generalized Inverted Index):
    - Быстро выполняет поиск.
    - Эффективность сохраняется при большом количестве слов.
    - Медленные обновления.
  - GiST (Generalized Search Tree):
    - Обновляется быстрее, чем GIN.
    - Эффективность снижается с увеличением количества слов.
  - RUM (Reusable Materialized):
    - Основан на GIN; поддерживает хранение позиций токенов.
    - Ускоряет фразовый поиск и ранжирование результатов.
- Создание индекса:
  ```sql
  CREATE INDEX ON table USING gin(tsvector_column);
  ```
- Оптимизация поиска:
  - Используйте столбец `tsvector`, чтобы избежать повторных вычислений:
    ```sql
    ALTER TABLE table ADD search_vector tsvector GENERATED ALWAYS AS (
      to_tsvector('english', column1 || ' ' || column2)
    ) STORED;
    ```
  - Сочетайте предвычисленные векторы с GIN или RUM индексами для ускорения поиска.

#### Разное в PostgreSQL
**Пример рекурсивного запроса:**
```sql
CREATE TABLE geo (
    id int not null primary key,
    parent_id int references geo(id),
    name varchar(1000)
);

INSERT INTO geo
(id, parent_id, name)
VALUES
(1, null, 'Планета Земля'),
(2, 1, 'Континент Евразия'),
(3, 1, 'Континент Северная Америка'),
(4, 2, 'Европа'),
(5, 4, 'Россия'),
(6, 4, 'Германия'),
(7, 5, 'Москва'),
(8, 5, 'Санкт-Петербург'),
(9, 6, 'Берлин');

-- Рекурсивный запрос, r - временная таблица
EXPLAIN WITH RECURSIVE r AS (
   SELECT id, parent_id, name
   FROM geo
   WHERE parent_id = 4

   UNION

   SELECT geo.id, geo.parent_id, geo.name
   FROM geo
   JOIN r ON geo.parent_id = r.id
)
SELECT * FROM r;
```

**Когда использовать неструктурированные типы данных (JSON/JSONB/Hstore)?**
+ JSONB — В большинстве случаев когда нужно NoSql (то есть мы не можем описать схему данных). Пример:
    ```postgresql
    CREATE TABLE integrations (id UUID, data JSONB);

    INSERT INTO integrations VALUES (
        uuid_generate_v4(),
        '{
            "service": "salesforce",
            "id": "AC347D212341XR",
            "email": "craig@citusdata.com",
            "occurred_at": "8/14/16 11:00:00",
            "added": {
                "lead_score": 50
            },
            "updated": {
                "updated_at": "8/14/16 11:00:00"
            }
       }');
    ```
    + Примеры запросов получения данных из JSONB столбца:
        ```postgresql
        --Получаем только те записи, в которых в объекте entity имеется поле contractId=1001
        select data from event_log
        WHERE data-> 'entity' -> 'contractId' = '1001';
        
        --Фильтруем записи по наличию в data объектов с status=WARNING (только 1ый уровень вложенности)
        select * from event_log WHERE data @> '{"status": "WARNING"}';
        
        --Фильтруем записи по наличию в массиве errors объектов с shortName=OrgInfoProxyException
        select * from event_log
        WHERE data @> '{"errors":[{"shortName": "OrgInfoProxyException"}]}';
        
        --Получаем значение объекта entity (только на 1ом уровне вложенности)
        select data::json->>'entity' as entity from event_log;
        
        --Получаем значения поля id вложенного в объект entity
        select data::json#>'{entity, id}' as id from event_log;
        ```
+ JSON — Если вы обрабатываете логи, вам не часто приходится запрашивать данные или не нужно использовать их как что-то большее чем для задач логирования.
+ Hstore — отлично работает с текстовыми данными на основе представления ключ-значение, но в целом JSONB также отлично справляется с этой задачей.
+ Подробнее [habr](https://habr.com/ru/post/306602/)

**Что такое `pg_stat_statements`?**  
+ Расширение для сбора статистики выполнения запросов. Помогает найти самые «тяжёлые» запросы и оптимизировать их. 
+ Пример:  
    ```sql
    CREATE EXTENSION pg_stat_statements;
    
    SELECT query, calls, total_exec_time, mean_exec_time
    FROM pg_stat_statements
    ORDER BY total_exec_time DESC
    LIMIT 5;
    ```

**Что делает команда `CREATE EXTENSION`?**  
+ **Не скачивает** расширения.  
+ Подключает расширение, чьи файлы уже установлены вместе с PostgreSQL или пакетом `contrib`.  
+ Выполняет SQL-скрипт из `$SHAREDIR/extension`.  
+ Регистрирует расширение в текущей базе (`pg_extension`).
+ Пример:  
    ```sql
    CREATE EXTENSION pg_trgm;
    ```
  
---

## NoSQL СУБД
+ Подробнее [habr](https://habr.com/ru/company/oleg-bunin/blog/319052/)

### Сравнение NoSQL с SQL
+ SQL (Structured Query Language) — универсальный язык запросов, который используется всеми реляционными системами.
+ NoSQL имеют собственный API для взаимодействия.
+ Преимущества РСУБД — соответствия базы данных требованиям ACID, целостность данных, структурированность.
+ Преимущества NoSQL — гибкая структура данных, скорость обработки данных, масштабируемость, распределённость систем.
+ Подробнее [habr](https://habr.com/ru/sandbox/113232/)

### Типы NoSql СУБД
+ Key/value хранилища
    + Хранение в виде ассоциативного массива. Минимальный интерфейс для такой базы данных состоит всего из 3-х операций — get, set и delete
    + Примеры
        + Memcashed
        + Redis (с натяжкой)
        + Riak
        
+ Документ-ориентированные базы данных
    + Это сильно усложненный вариант предыдущей категории. Эта добавленная сложность — она дает ещё и бонусы: теперь значения — это не какой-то непрозрачный текстовый блоб, с которым ничего нельзя делать, кроме того, что целиком прочитать или удалить, а теперь можно работать более тонко со значением. Если нам нужна только часть документа, можем ее прочитать или обновить только часть
    + Примеры
        + MongoDB 
        + CouchDB
        + ElasticSearch
    
+ Колоночные базы данных
    + Есть файл — в нем хранятся все поля данной колонки из всех N млрд. записей, хранятся все рядом. Соответственно, другая колонка хранится в другом файле. За счет этого они могут применять улучшенное сжатие за счет использования информации о типе данных колонки. Также это может ускорять запросы, если, нам, например, нужны 3 колонки из 300, то нам не обязательно грузить остальные 297.
    + Примеры
        + HBase
        + Cassandra
        + Vertica
        + ClickHouse
    
+ Графовые базы данных
    + Сила этих баз данных в том, что за счет своей специализации они могут эффективно выполнять всякие операции над графами, но также в силу той же специализации они не сильно распространены
    + Примеры
        + Neo4j
    
+ Мультимодельные базы данных
    + Это такие базы данных, в которые одновременно входит две или более категорий из предыдущих.
    + Примеры
        + FoundationDB
        + ArangoDB
        + OrientDB

### ElasticSearch
Подробнее [habr](https://habr.com/ru/companies/sportmaster_lab/articles/756004/)

Распределенная документно-ориентированная БД с мощными возможностями поиска. 
Для быстрого поиска Elasticsearch использует под капотом специальные структуры данных, например обратный индекс (inverted index)
