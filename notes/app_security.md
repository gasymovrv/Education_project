# Безопасность и методы защиты приложений

## Injections
+ Внедрение специального кода в приложение при недостаточной/отсутствующей проверке данных от пользователя
+ Например, при отправке данных через инпуты или в виде параметров в урл,
 SQL инъекция может внести какие-то неправомерные изменения данных или структуры данных
+ **ПРИМЕР**:
    + SQL-инъекция в запросе ('%20' - это пробел, '--' - это начало комментария чтобы отбросить пароль):
    ```
    site.com?username=admin'%20--%20&pass='1'
    ```
    + Небезопасная обработка параметров на сервере:
    ```
    String sql = "select * from user where username = '" + username + "' and pass= '" + pass + "'";
    ```
+ **ЗАЩИТА**:
    + Фильтрация параметров, работающих с базой данных
        + Проверка валидности числовых параметров
        + Проверка валидности строковых параметров
        + Экранирование символов
        + В Java при передаче параметров в SQL-запрос вместо конкатенации запроса использовать PreparedStatement - 
        он автоматически экранирует ковычки (Hibernate тоже испольует его в named query)


## Broken Authentication and Session Management
+ Неправильная реализация механизмов аутентификации и сессий
+ Для того, чтобы отличать одного пользователя от другого, 
web-приложение использует так называемые сессионные куки. После того, как Вы ввели логин и пароль и приложение вас авторизовало, в хранилище браузера сохраняется специальный идентификатор, который браузер в дальнейшем предъявляет серверу при каждом запросе страницы вашего web-приложения. 
Именно так web-приложение понимает, что Вы это именно Вы.
+ **ПРИМЕР**:
    + Разрешаем автоматические атаки (не имеем капчи)
    + Разрешаем слабые или известные пароли, такие как «Пароль: 1» или «admin / admin»
    + Использует простые текстовые, зашифрованные или слабо хешированные пароли
    + Отсутствует или неэффективна многофакторная аутентификация
    + Выдает идентификаторы сеанса в URL-адресе, для тех кто отправляет пароли, куки, юзеров в урле либо через GET запросы в API
+ **ЗАЩИТА(общая)**:
    + Многофакторная аутентификация для предотвращения автоматических атак
    + Не отправляйте в URL данные для работы с приложением
    + Внедрение проверок с плохими паролями 
    + Ограничение или увеличение задержки неудачных попыток входа в систему, с появлением капчи
+ **ЗАЩИТА(от кражи сессий)**:
    1. Проверка сеанса:
        + Добавить дату на истечение срока сессии. 
        Чтобы, даже если и хацкер каким-то образом нашел вашу сессию, то по истечению  времени, 
        она не была уже действительной.
        + Проверка IP-адреса сессии (только для статических IP)
        + Проверки наличия более одного соединения в одной сессии
    2. Защита сессии IDs:
        + ID сессии должна быть уникальна и рандомная. 
        Дабы никто не мог работать под той же сессией, что и вы.
        + ID сессии должны защищаться флагами ```Secure``` (передача только https) и ```HTTPonly```. 
        С этими атрибутами, при попытке атакующего перехватить ваш запрос, будет скрыта вся информация про ваши куки и сессии вообще.
        + Всегда перегенерировать куку при увеличении привилегий в системе. Возьмем, за пример авторизацию. Когда вы не залогиненный пользователь у вас должна быть одна кука, в случаи, если вы хотите авторизоваться на сайте для получения доступа на какие-то страницы, вам должны дать совсем другую уникальную куку, а та которая была, должна удалится.
    3. Защита хранимой сессии:
        + Все сессии должны хранится на стороне сервера, чтоб на фронте они не мелькали, так как на фронте они намного уязвимей чем на стороне сервака.
        + Подчищать куки в сессии не дожидаясь даты окончания кук
        + При разлогиннивании пользователя убивать сессию
        
        
## XSS (Cross Site Scripting)
+ Межсайтовый скриптинг - ошибка валидации пользовательских
данных, которая позволяет передать JavaScript код на исполнение в
браузер пользователя.
+ Атаки такого рода часто также называют ```HTML-инъекциями```,
 ведь механизм их внедрения очень схож с SQL-инъекциями,
но в отличие от последних, внедряемый код исполняется в браузере
+ Например, разместив комментарии со скриптом отправляющим куки или ID сессии пользователя на сторонний сервер злоумышленника
пользователя.
+ **ПРИМЕР**:
    + ПРИМЕР ОТРАЖЕННОЙ ИЛИ АКТИВНОЙ XSS АТАКИ:
    ```http://vulnsite.com/search.php?q=<script>XSS();</script>```
    + ПАССИВНАЯ АТАКА - хакерский запрос сохраняется в БД и срабатывает при обращении пользователя к нему
    + Практически любой счетчик посещений сайта или аналитический инструмент по типу Google Analytic является XSS атакой, собирая данные о посетителях.
    + Кроссдоменные AJAX запросы также можно отнести к безвредным XSS атакам.
+ **ЗАЩИТА**:
    + Фильтрация параметров входных данных, передаваемых GET, POST, COOKIE
    + Кодирование входных данных
    + Экранирование спецсимволов HTML


## Insecure Direct Object References
+ Незащищенные ресурсы и объекты
+ Суть ее заключается в том, что при выводе каких-либо конфиденциальных данных, например личных сообщений или учетных карточек клиентов, 
для доступа к объекту используется идентификатор, который передается в открытом виде в адресной строке браузера, 
и не реализована проверка прав доступа к объектам.
+ **ПРИМЕР**:
    + Например, есть страница, которая отображает личное сообщение и она имеет адрес вида:
    ```mysite.ru/read_message.jsp?id=123654```
    + Перебором ID-шников можно будет читать чужие сообщения
+ **ЗАЩИТА**:
    + Непередавать внутренние идентификаторы, либо проверять наличие прав доступа на них


## Security Misconfiguration
+ Небезопасная конфигурация окружения
+ Безопасность Web-приложения требует наличия безопасной
  конфигурации всех компонентов инфраструктуры: компонентов
  приложения (таких как фреймворки – frameworks), веб-сервера, сервера
  баз данных и самой платформы. Настройки компонентов сервера по-
  умолчанию зачастую небезопасны и открывают возможности к атакам.
+ **ПРИМЕР**:
    + Например, кража сессионной cookie через JavaScript при XSS-атаке
        становится возможна благодаря выключенной по-умолчанию настройке
        cookie_http only.
+ **ЗАЩИТА**:
    + Всегда проверять настройки БД, сервера, фреймворков и т.д.


## Missing Function Level Access Control
+ Отсутствие проверки прав доступа на уровне функций
+ Большинство веб-приложений проверяют права доступа, прежде чем
  отобразить данные в пользовательском интерфейсе. Тем не менее,
  приложения должны выполнять те же проверки контроля доступа на
  сервере при запросе любой функции. Ведь есть еще множество
  вспомогательных служебных запросов, которые, зачастую отправляются
  в фоновом режиме асинхронно, при помощи технологии AJAX.
+ **ПРИМЕР**:
    + Частный, и пожалуй, самый распространенный случай данной
      уязвимости мы уже рассмотрели в ```Insecure Direct Object References``` – отсутствие
      проверки пользователя в личных сообщениях.
+ **ЗАЩИТА**:
    + Дополнительные проверки прав доступа в подзапросах


## Cross-Site Request Forgery (CSRF)
+ Межсайтовая подделка запроса
+ Жертва заходит на сайт, созданный злоумышленником, 
    который от её лица отправляет запрос на другой, легальный сервер, 
    к примеру на сервер платёжной системы.
    Предполагается, что жертва должна была предварительно пройти аутентификацию в платежной системе и 
    должна быть открыта активная сессия (скажем, страница платежной системы открыта в другой вкладке браузера).
+ Защищать необходимо небезопасные методы, к которым относятся: POST, PUT, DELETE, PATCH.
+ **ПРИМЕР**:
    + Например, в некоторой платежной системе для перевода средств на другой аккаунт, есть страница вида:
    ```demobank.com/transfer_money.jsp?transfer_amount=1000&transfer_account=123456789```
    где transfer_amount – сумма для перевода и transfer_account – номер аккаунта, куда должны быть переведены средства.
+ **ЗАЩИТА**:
    + Все делать через POST (т.к. он скрывает параметры в теле)
    + Эффективным и общепринятым на сегодня способом защиты от CSRF-Атаки является токен. 
    Под токеном имеется в виду случайный набор байт, который сервер передает клиенту, а клиент возвращает серверу.
    Защита сводится к проверке токена, который сгенерировал сервер, и токена, который прислал пользователь.
    + ПОДРОБНЕЕ О ТОКЕНАХ
        + При старте сессии на стороне сервера генерируется токен.
        + Токен кладется в хранилище данных сессии (т.е. сохраняется на стороне сервера для последующей проверки)
        + В ответ на запрос (который стартовал сессию) клиенту возвращается токен.
        + Если рендеринг происходит на сервере, то токен может возвращаться внутри HTML, как, например, одно из полей формы, или внутри ```<meta>``` тега 
        + В случае, если ответ возвращается для JS приложения, токен можно передавать в header (часто для этого используют X-CSRF-Token)
        + При последующих запросах клиент обязан передать токен серверу для проверки.
        + При рендере контента сервером токен принято возвращать внутри POST данных формы.
        + JS приложения обычно присылают XHR запросы с header (X-CSRF-Token), содержащим токен.
        + При получения запроса небезопасным методом (POST, PUT, DELETE, PATCH) сервер обязан проверить на идентичность токен из данных сессии и токен, который прислал клиент.
        + Если оба токена совпадают, то запрос не подвергся CSRF-Атаке, в ином случае — логируем событие и отклоняем запрос.

## Using Components with Known Vulnerabilities	
+ **ПРИМЕР**:
    + Использование компонентов с известными уязвимостями
+ **ЗАЩИТА**:
    + Использовать последние версии компонентов и следить за появляющимися известными уязвимостями на сайтах типа securityfocus.com.

## Unvalidated Redirects and Forwards
+ Непроверенные переадресации и пересылки
+ 
+ **ПРИМЕР**:
    + Безвердный редирект:
    ```http://www.example.com/redirect?url=amazon.com```
    + Редирект на хакерский сайт
    ```
    http://www.mysite.com/redirect?url=mysite.com/profile
    http://www.mysite.com/redirect?url=malicous.com/attack
    ```
+ **ЗАЩИТА**:
    + Не позволять редиректы с вводом от пользователя
    + Белый список урлов
