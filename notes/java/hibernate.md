# Hibernate
## Важные нюансы
+ Проблемы с Lazy=true
    + Свойство lazy=true – автоматическое запонение вложенных сущностей хибернейтом, если к ним обращаются в рамках одной сессии
    + Если печатать в консоль вложенные сущности из базы, то Lazy работает только внутри бина. 
    + Если вызываем через getBean из ApplicationContext, то на этот момент сессия уже закрыта и поэтому не получается подтянуть вложенные сущности
+ Удаление сирот и каскады
    + Если установлено более лояльное свойство чем Cascade=all-delete-orphan, например Cascade=all или Cascade=save-update, то сирот  придется удалять вручную - удаляя зависимые объекты.
+ Транзакции + ошибки transaction-synchronized
    + Метод помеченный @Transactional будет транзакцией. Если вызывать внутри него методы с такой же аннотацией, то внутренняя транзакция станет частью внешней (если свойство propagation не изменено). 
    + Получение сессии методом getCurrentSession() необходимо осуществлять только в методе аннотированном @Transactional, иначе ошибка ... transaction-synchronized
    + Если внутри транзакции была получена сессия методом getCurrentSession(), то закроется она с завершением последнего метода с @Transactional
+ Вызов метода c @Transactional в другом методе с @Transactional в том же бине
    + Т.к. перехват @Transactional реализован с помощью аспектов Spring AOP (на основе проксирования), то такие вызовы не стартуют транзакцию
    + Выхода 2: переключиться на аспекты AspectJ или вынести метод в другой бин
+ org.hibernate.LazyInitializationException
    + Если в каком-то методе БЕЗ @Transactional инициировать заполнение вложенных сущностей (только если lazy=true), то возникает org.hibernate.LazyInitializationException, т.к. сессия уже закрылась.

## Стратегии наследования

#### TABLE_PER_CLASS
+ Отдельные таблицы для каждого класса кроме родителя (его поля будут во всех таблицах БД)
+ Полиморфные запросы будут через UNION - лучше для производительности
+ Id обязательно должен быть вынесен в родителя
+ [TABLE_PER_CLASS](/hibertest/src/main/java/hibertest/tableperclass)

#### SINGLE_TABLE
+ Единая таблица для всей иерархии классов, поля всех классов собраны в кучу
+ Очень плохо для структуры БД и поддержки, но очень быстро
+ [SINGLE_TABLE](/hibertest/src/main/java/hibertest/singletable)

#### JOINED_TABLE
+ Отдельные таблицы для каждого класса (даже для родителя)
+ Родитель с детьми в БД будут иметь связь по внешнему ключу
+ Полиморфные запросы будут через JOIN - возможны проблемы с производительностью
+ Но хорошо нормализованная БД
+ [JOINED_TABLE](/hibertest/src/main/java/hibertest/joinedtable)

#### MAPPED_SUPERCLASS
+ Не является стратегией наследования в прямом смысле, т.к. родитель не entity
+ Отдельные таблицы для каждого класса кроме родителя (его поля будут во всех таблицах БД)
+ Полиморфные запросы (через вызов родителя) будут через отдельные селекты - плохо для производительности
+ [MAPPED_SUPERCLASS](/hibertest/src/main/java/hibertest/mappedsuperclass)


## Проблема N+1
+ N+1 проблема в Hibernate состоит в том, что вместо одного явного select выполняется N+1 неявных select-ов, что сильно сказывается на производительности
+ Например есть связь One-to-many - сущность Новость содержит несколько Комментариев
    + При попытке получить новости со всеми комментариями к ним, hibernate сделает 1 селект для получения списка новостей и N (где N - кол-во новостей) селектов для получения комментариев    
+ Решения
    + @Fetch(FetchMode.JOIN)
        + Вложенные сущности будут подтягиваться джойном. Минус в том что ограничение limit будет работать на общее кол-во записей, а не на главные сущности. Также есть ограничение на вытягивание других вложенных сущностей (если нужно получить несколько one-to-many зависимостей)
    + @Fetch(FetchMode.SUBSELECT)
        + Вложенные сущности будут подтягиваться субселектом