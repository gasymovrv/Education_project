# Основные понятия по фреймворкам Spring

## Spring Core
+ Основные этапы поднятия ApplicationContext:
	+ ...BeanDefinitionReader - чтение конфигов и создание BeanDefinition
		+ Виды конфигов:
			+ xml - ClassPathXmlApplicationContext(“context.xml”)
			+ javaConfig - класс с @Configuration: AnnotationConfigApplicationContext(JavaConfig.class)
			+ annotations - пакета для сканирования: AnnotationConfigApplicationContext(“package.name”)
			+ groovy - GenericGroovyApplicationContext(“context.groovy”)
		+ На выходе мапа Map<BeanId, BeanDefinition>
	
	+ Создание BeanFactory и настройка BeanDefinition (мета данные о бинах)
		можно перехватить и донастроить BeanDefinition через BeanFactoryPostProcessor
		на этом этапе парсятся проперти для @Value

	+ Создание кастомных FactoryBean - фабрика создания бинов (актуально только для xml конфига)

	+ Создание экземпляров бинов (только не lazy - например синглтон, он по умолчанию не lazy)
		+ Созданием экземпляров бинов занимается BeanFactory при этом, если нужно, делегирует это кастомным FactoryBean
		+ На выходе мапа Map<BeanId, Bean>
		+ Тут происходит инжекция бинов 
		+ Лучше инжектить через конструктор - так поля можно сделать final и создавать бин сразу со всеми необходимыми зависимостями (к тому же это не позволит создать циклическую зависимость, а например через поля или сеттеры это возможно)

	+ Донастройка созданных бинов
		+ Можем вклиниться с помощью BeanPostProcessor 
		
## Spring Boot
+ Отличия от простого Spring:
    + Наличие автоконфигураций - стартеры (реализованы через @ConditionalOnProperty)
    + Встроенный контейнер сервлетов - для Spring-MVC - Tomcat, для Spring-Webflux - Netty

## Spring Security
+ [Spring Security](https://habr.com/ru/post/203318/)
+ [Протокол OAuth 2.0](../security.md#Протокол-OAuth-20)
+ [Spring Boot OAuth2 и JWT](https://habr.com/ru/company/otus/blog/453664/)

## Spring Webflux
+ Отличия от Spring MVC (подробно о Webflux [тут](https://habr.com/ru/company/funcorp/blog/350996/))
	+ В основе WebFlux лежит библиотека Reactor
	+ Вместо tomcat использует netty
	+ Использует неблокирующую многопоточность
	+ Текущий поток выполнения не блокируется и ждет, а переключается на что-нибудь полезное, вернувшись к текущему процессу, когда асинхронная обработка будет завершена
	+ Требуется меньше потоков благодаря предыдущему пункту
	+ Дебаг и разработка сложнее
	+ Работает лучше чем Spring-MVC при большом количестве легких запросов
	+ Работает хуже чем Spring-MVC если имеются тяжелые/длительные процессы
	+ Что произойдет под большой нагрузкой?
	    + Spring MVC с блокирующей многопоточностью будет просто висеть заблокированным, если количество одновременно обрабатываемых запросов достигло предела количества тредов (другие запросы будут ждать освобождения треда)
	    + Spring WebFlux с неблокирующей многопоточностью будет постоянно брать в работу новые реквесты (даже если их больше чем тредов), создавать на каждый отложенную задачу и, если их обработка будет медленнее (например долгое обращение к бд, даже не блокирующей) чем поступление новых, то переполнится буфер