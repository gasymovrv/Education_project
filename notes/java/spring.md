# Основные понятия по фреймворкам Spring

## Spring Core
+ Преимущества
    + Паттерн IoC - Inversion of Control - мы выносим контроль за подключением зависимостей (созданием и инжектом бинов) наружу из нашей бизнес логики. В спринге созданием бинов занимается ApplicationContext
    + Благодаря этому получаем гибкость реализаций. Т.к. мы инжектим бины через интерфейсы, то есть можем легко менять реализации
+ Основные этапы поднятия ApplicationContext:
	+ ...BeanDefinitionReader - чтение конфигов и создание BeanDefinition
		+ Виды конфигов:
			+ xml - ClassPathXmlApplicationContext(“context.xml”)
			+ javaConfig - класс с @Configuration: AnnotationConfigApplicationContext(JavaConfig.class)
			+ annotations - пакета для сканирования: AnnotationConfigApplicationContext(“package.name”)
			+ groovy - GenericGroovyApplicationContext(“context.groovy”)
		+ На выходе мапа Map<BeanId, BeanDefinition>
	
	+ Создание BeanFactory и настройка BeanDefinition (мета данные о бинах)
		можно перехватить и донастроить BeanDefinition через BeanFactoryPostProcessor
		на этом этапе парсятся проперти для @Value

	+ Создание кастомных FactoryBean - фабрика создания бинов (актуально только для xml конфига)

	+ Создание экземпляров бинов (только не lazy - например синглтон, он по умолчанию не lazy)
		+ Созданием экземпляров бинов занимается BeanFactory при этом, если нужно, делегирует это кастомным FactoryBean
		+ На выходе мапа Map<BeanId, Bean>
		+ Тут происходит инжекция бинов 
		+ Лучше инжектить через конструктор - так поля можно сделать final и создавать бин сразу со всеми необходимыми зависимостями (к тому же это не позволит создать циклическую зависимость, а например через поля или сеттеры это возможно)

	+ Донастройка созданных бинов
		+ Можем вклиниться с помощью BeanPostProcessor 
		
## Spring Boot
+ Отличия от простого Spring:
    + Использование так называемых Starter, которые позволяют получить набор сконфигурированных бинов, готовых к использованию и доступных для конфигурации через application.yml-файлы
        + Бины автоконфигураций уже написаны в spring-boot-autoconfigure, но создаются только по @Conditional/@ConditionalOnClass/ConditionalOnProperty
            + Например конфиг-бин `FlywayAutoConfiguration` имеет аннотацию `@ConditionalOnClass(Flyway.class)`
            + Т.е. он создается когда мы подклчюаем зависимость которая содержит класс `Flyway.class`, например эту - `implementation "org.flywaydb:flyway-core"`
        + ?? Часть из них подключается через spring.factories. Они соблюдают инверсию контроля и open closed principle — несут свои spring.factories, в которых прописаны их кишки
        + ?? Часть конфигураций просто захардкожена в Spring Boot
    + Стартеры позволяют решить проблемы конфликта зависимостей. Они содержат все необходимые для их сферы зависимости, а т.к. spring-boot подключается как родитель или dependency-менеджер, то мы имеем все их версии. Блок dependency-менеджмента не прописывает зависимости. Это блок, при помощи которого можно указать версии на случай, если эти зависимости будут нужны
    + Встроенный контейнер сервлетов - для Spring-MVC - Tomcat, для Spring-Webflux - Netty
+ Подробнее [тут](https://habr.com/ru/company/jugru/blog/424503/)

## Spring Security
+ [Spring Security](https://habr.com/ru/post/203318/)
+ [Протокол OAuth 2.0](../security.md#Протокол-OAuth-20)
+ [Spring Boot OAuth2 и JWT](https://habr.com/ru/company/otus/blog/453664/)

## Spring Webflux
+ Отличия от Spring MVC (подробно о Webflux [тут](https://habr.com/ru/company/funcorp/blog/350996/))
	+ В основе WebFlux лежит библиотека Reactor
	+ Вместо tomcat использует netty
	+ Использует неблокирующую многопоточность
	+ Текущий поток выполнения не блокируется и ждет, а переключается на что-нибудь полезное, вернувшись к текущему процессу, когда асинхронная обработка будет завершена
	+ Требуется меньше потоков благодаря предыдущему пункту
	+ Дебаг и разработка сложнее
	+ Работает лучше чем Spring-MVC при большом количестве легких запросов
	+ Работает хуже чем Spring-MVC если имеются тяжелые/длительные процессы
	+ Что произойдет под большой нагрузкой?
	    + Spring MVC с блокирующей многопоточностью будет просто висеть заблокированным, если количество одновременно обрабатываемых запросов достигло предела количества тредов (другие запросы будут ждать освобождения треда)
	    + Spring WebFlux с неблокирующей многопоточностью будет постоянно брать в работу новые реквесты (даже если их больше чем тредов), создавать на каждый отложенную задачу и, если их обработка будет медленнее (например долгое обращение к бд, даже не блокирующей) чем поступление новых, то переполнится буфер