# Java

### Java EE
1. Это просто набор спецификаций описанный в определенных стандартах:
    + **EJB** - Enterprise JavaBeans — спецификация технологии серверных компонентов, содержащих бизнес-логику
    + **JPA** - Java Persistence API — управление постоянством и объектно-реляционное отображение
    + **Servlet** - Обслуживание запросов веб-клиентов
    + **JSP** - JavaServer Pages — динамическая генерация веб-страниц на стороне сервера
    + **JSTL** - JavaServer Pages Standard Tag Library
    + **JSF** - JavaServer Faces — компонентный серверный фреймворк для разработки веб-приложений на технологии Java
    + **JAX-WS** - Java API for XML Web Services — создание веб-сервисов
    + **JAX-RS** - Java API for RESTful Web Services — создание RESTful веб-сервисов
    + **WebSocket** - Java API for WebSocket
    + **JSON-P** - Java API for JSON Processing — разбор и генерация JSON
    + **JSON-B** - Java API for JSON Binding — преобразование Java объектов в/из JSON
    + **JNDI** - Java Naming and Directory Interface — служба каталогов
    + **JMS** - Java Message Service — обмен сообщениями
    + **JTA** - Java Transaction API — управление транзакциями
    + **JAAS** - Java Authentication and Authorization Service — Java-реализация PAM	
    + **JavaMail** - Получение и отправка электронной почты
    + **JACC** - Java Authorization Contract for Containers
    + **JCA** - J2EE Connector Architecture
    + **JAF** - JavaBeans Activation Framework
    + **StAX** - Streaming API for XML
    + **CDI** - Context and Dependency Injection
    + **Validation** - Bean Validation
    + **Security** - Java EE Security API
1. В JDK есть интерфейсы и классы для использования этих стандартов
1. Реализация выполнена на серверах приложений (у каждого свой набор). Эталоным считается Glassfish, остальные расширяют его

### Методы Object
1. `int hashCode()` - возвращает хеш-код объекта
1. `boolean equals(Object obj)` - определяет, равен ли текущий объект другому
1. `Object clone()` - клонирует объект
1. `void finalize()` - вызывается перед удалением неиспользуемого объекта
1. `Class<?> getClass()` - получает класс объекта во время выполнения
1. `void notify()` - возобновляет выполнение потока, который ожидает вызывающего объекта
1. `void notifyAll()` - возобновляет выполнение всех потоков, которые ожидают вызывающего объекта
1. `String toString()` - возвращает строку, описывающую объект
1. `void wait()` - ожидает другого потока выполнения (есть перегрузки с параметром времени ожидания)

### Синтаксис Java
+ Наследование
+ Множественное насл-ие - в Java оно есть только для интерфейсов, что избавляет от проблемы совпадения имен методов
    + Совпадение имен методов в интерфейсах не приводит к проблемам, т.к. реализации они еще не имеют
    + Если совпадение имен произойдет с дефолтными методами, то программа не скомпилируется
+ Перегрузка - возвращаемые типы могут отлчиаться - это разные методы
+ Переопределение - возвращаемые типы могут сужаться, но не расширяться

### JVM компоненты
+ Classloader - загрузка классов из classpath
+ Garbage Collector - автоматическое управление памятью - heap (очень подробно [тут](https://habr.com/ru/post/269621/))
    + Serial - самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.
    + Parallel - наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. Если на вашем компьютере больше одного процессорного ядра и вы явно не указали, какой сборщик хотите использовать в своей программе, то почти наверняка JVM остановит свой выбор на Parallel GC
    + CMS - нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти.
    + G1 - самый современный. Создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных.
+ JIT-компилятор - динамическая компиляция байт кода в машинный код
+ компоненты управления потоками
+ и др.

+ Типы памяти
    + heap - хранятся объекты, чистится GC, общий на все приложение;
    + stack - хранятся локальные примитивы в методах и ссылки на объекты, чистится при завершении метода, потокобезопасен (отдельный стек на каждый поток)
    + Нативная память (состоит из нескольких областей) - классы, кэш JIT компилятора и др.
    
### Правила реализации equals/hashCode
+ `equals`:
    + Рефлексивность: Объект должен равняться себе самому.
    + Симметричность: если `a.equals(b) == true`, то `b.equals(a)` должен тоже быть `true`.
    + Транзитивность: если `a.equals(b) == true` и `b.equals(c) == true`, то `c.equals(a)` тоже должен быть `true`.
    + Согласованность: повторный вызов метода `equals()` должен возвращать одно и тоже значение, пока какое-либо значение свойств объекта не будет изменено
    + Сравнение с `null`: `a.equals(null)` должен вернуть `false`, а не NPE.
+ `hashcode`:
    + Должен использовать для вычисления те же поля что и `equals()`
    + У двух одинаковых объектов `hashcode` ДОЛЖЕН быть одинаковым
    + У двух разных объектов `hashcode` МОЖЕТ быть одинаковым (это коллизия, лучше чтобы такого не было)
+ Разное
    + Лучше делать объекты для ключей immutable, либо следует выбирать уникальные и не изменяющиеся во время жизни обьекта поля
    + Если hashcode не переопределить, то результат при работе с hash-коллекциями может быть непредсказуемым - будут добавляться одинаковые объекты (т.к. их хеши оказались разными) или не получится найти идентичный объект
    + Если hashcode сделать константой, то преимущество при работе с hash-коллекциями теряется, т.к. все элементы будут складываться в одну корзину

### Java Collections API
+ Производительность коллекций см. [algorithms.md](../algorithms.md)
+ Пояснения о работе HashMap   
	+ HashMap представляет из себя массив связных списков (корзин), дефолтный length которого = 16.
	+ Индекс вставки рассчитывается как ((length-1) & hash) - так всегда получается число в дипазаоне изначального length.
	    + где hash - это особый хеш из реализации HashMap на основе hashCode вставляемого ключа - гарантирует что коллизий будет не более 8 (элементов связного списка) с дефолтным capacity/loadfactor и правильным hashCode

	+ **put**:
	    + Вычислили индекс вставки
	    + Нашли корзину по этому индексу (если ее нет, то создали новую с этим элементом и на этом заканчиваем)
	    + Поочередно сравниваем хэши вставляемого элемента с хэшами элементов из корзины и если:
	    	+ Они идентичны. Далее проверяется equals:
	    	    + equals == true - значение элемента перезаписывается.
	    	    + equals == false - элемент добавялется в текущую корзину как новый элемент
	    	+ Они НЕ идентичны. Элемент добавялется в текущую корзину как новый элемент

	+ **get**:
        + Вычислили индекс вставки
        + Нашли корзину по этому индексу (если ее нет, то возвращаем NULL)
        + Поочередно сравниваем хэши искомого элемента с хэшами элементов из корзины и если:
            + Они идентичны. Далее проверяется equals:
                + equals == true - возвращаем ЭЛЕМЕНТ.
                + equals == false, то возвращаем NULL

    + Чем больше корзин, тем меньше коллизий - меньше итераций внутри корзин, но больше памяти потребуется (когда loadFactor меньше) 
    + Чем меньше корзин, тем больше коллизий - меньше памяти, но больше итераций при поиске. (когда loadFactor больше)

### Пул строк
+ Пул строк – это набор строк, который хранится в памяти Java heap (не точно, есть инфа что он хранится в отдельной области памяти)
+ Сам строковый пул возможен только потому, что строки в Java неизменные
+ Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка. Тем не менее, создавая через ```new String("строка")```, мы можем принудительно создать новый объект
+ Метод intern()
    + Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка на строку из пула. 
    + В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.

### WeakReference, SoftReference и др.
+ Strong Reference - самая простая, так как мы используем ее в программировании изо дня в день, например в коде вида ```String s = "abc"``` переменная s это и есть strong ссылка. Любой объект что имеет strong ссылку запрещен для удаления сборщиком мусора
+ Weak Reference
    + Слабые ссылки представлены классом java.lang.ref.WeakReference, вы можете определить слабую ссылку так:
    ```java
    Counter counter = new Counter();
    WeakReference weakCounter = new WeakReference(counter);
    counter = null;
    ```
    + Теперь, как только вы присвоили strong ссылке counter значение null (counter = null), тот объект что создан в первой строке становится доступным для удаления сборщиком мусора, потому что он больше не имеет strong ссылки. Cозданная Weak ссылка weakCounter не может предотвратить удаление сборщиком объекта Counter
+ Soft Reference
    + Пример создания SoftReference в Java:
    ```java
    Counter counter = new Counter();
    SoftReference soft = new SoftReference(counter);
    counter = null;
    ```
    + После обнуления strong ссылки (в 3-ей строке) на объект Counter останется только 1 мягкая ссылка которая не сможет предотвратить удаление этого объекта сборщиком мусора, но в отличие от weak ссылки сможет отложить этот процесс до тех пор пока не появится острая нехватка памяти
+ Phantom Reference - объект на который указывают только phantom ссылки может быть удален сборщиком в любой момент
+ Применение: учитывая отличие soft ссылки от weak, первая больше подходит для кэшей, а weak для метаданных
+ Подробнее [тут](https://javarush.ru/groups/posts/1267-otlichija-mezhdu-slabihmi-mjagkimi-fantomnihmi-i-obihchnihmi-ssihlkami-v-java)

### Утечки памяти (Memory leaks)
+ Утечка памяти — это ситуация, когда в куче есть объекты, которые больше не используются, но сборщик мусора не может удалить их, что приводит к нерациональному расходованию памяти. В итоге приложение исчерпает свои ресурсы и завершится с ошибкой java.lang.OutOfMemoryError.
+ Основные типы:
    + Утечки памяти из-за статических полей
        + В Java время жизни статических полей обычно совпадает со временем работы приложения. [Пример](../../src/main/java/examples/MemoryStaticTest.java)
        + Как это предотвратить?
            + Минимизировать использование статических переменных в приложении.
            + При использовании синглтонов использовать реализацию с ленивый загрузкой объекта, вместо немедленной.
    + Через незакрытые ресурсы
        + Всякий раз, когда мы создаем новое соединение или открываем поток, JVM выделяет память для этих ресурсов. Это могут быть соединения с базой данных, потоки ввода/вывода или сессионные объекты.
        + Как это предотвратить?
            + Всегда используйте finally блок для закрытия ресурсов.
            + Код (даже в блоке finally), который закрывает ресурсы, не должен иметь никаких необработанных исключений.
            + Для Java 7 и выше использовать блок try-with-resources.
    + Неверные реализации equals() и hashCode()
        + Неправильные реализации этих методов позволят создавать дубликаты в Map и они приведут к засорению памяти
        + Как это предотвратить?
            + Взять за правило, при создании новых сущностей (Entity), всегда переопределять методы equals() и hashCode() .
            + Не достаточно просто переопределить эти методы. Они должны быть переопределены оптимальным образом.
    + Внутренние классы, которые ссылаются на внешние классы
        + Каждый нестатический внутренний класс по умолчанию имеет неявную (скрытую) ссылку на класс в котором он находится. Если мы используем этот объект внутреннего класса в нашем приложении, то даже после того, как объект внешнего класса завершает свою работу, он не будет утилизирован сборщиком мусора.
        + Как это предотвратить?
            + Если внутреннему классу не нужен доступ к членам внешнего класса, подумайте о превращении его в статический класс.
    + Использование ThreadLocals
        + Поскольку пулы потоков в серверах приложений работают по принципу повторного использования потоков, они никогда не удаляются сборщиком мусора — вместо этого они повторно используются для обслуживания другого запроса.
        + Как это предотвратить?
            + Хорошей практикой является очищение ThreadLocal переменных, когда они больше не используются. ThreadLocal предоставляет метод remove(), который удаляет значение переменной для текущего потока
+ Подробнее [тут](https://topjava.ru/blog/java-memory-leaks)

## Многопоточность
+ volatile - указывает что JVM не должно кэшировать переменную (в кэше процессора) и ее всегда необходимо читать из памяти. Может помочь если в переменную пишет один поток, а другой затем читает. Без нее один поток может прочитать значение, сохранить себе в кэш и когда другой поток изменит ее, то первый не увидит изменения
+ Состояние гонки (Race condition) - Предположим, что потоки A и B выполняют метод getInstance в одно и то же время. A видит, что поле instance равно null, и создает новый ExpensiveObject. Поток B также проверяет, равно ли поле instance тому же значению null. Наличие в поле значения null в этот момент зависит от временной координации, включая капризы планирования и количество времени, нужного для создания экземпляра объекта ExpensiveObject и установки значения в поле instance. Если поле instance равно null, когда B его проверяет, два элемента кода, вызывающих метод getInstance, могут получить два разных результата, даже если метод getInstance предположительно должен всегда возвращать один и тот же экземпляр. [Пример](../../src/main/java/examples/multithreading/racecondition/RaceConditionTest.java)
    ```java
    @NotThreadSafe
    public class LazyInitRace {
          private ExpensiveObject instance = null;
    
          public ExpensiveObject getInstance() {
                if (instance == null)
                    instance = new ExpensiveObject();
                return instance;
          }
    }
    ```
+ java.lang.ThreadLocal - это такой тип для поля, привязанный к потоку. То есть, у каждого потока эта поле свое. Даже если это поле будет статическое, оно все равно у каждого потока будет свое.
    + Пример:
    ```java
    public class SecurityContextHolder {
    	private static final ThreadLocal<User> threadLocalScope = new  ThreadLocal<>();
    	
    	public final static User getLoggedUser() {
    		return threadLocalScope.get();
    	}
    	
    	public final static void setLoggedUser(User user) {
    		threadLocalScope.set(user);
    	}  
    }
    ```
    + Мы запоминаем текущего пользователя в статической переменной, а статическая переменная одна на весь класс, и вроде бы паралельные http запросы должны перетирать данные друг друга.
      Но вся фишка ThreadLocal заключается в том что имея всего одну ThreadLocal переменную, мы можем иметь различное значение для каждого из потоков, то есть один поток никогда не прочтет, не удалит или не перезатрет данные присвоенные другим потоком. Таким образом несмотря на разделяемую статическую переменную код выше потоко-безопасен.

### Пакет java.util.concurrent
+ Подробнее [тут](https://habr.com/ru/company/luxoft/blog/157273/)

#### Concurrent Collections
+ Набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wait-free алгоритмам.
    + CopyOnWrite коллекции - Все операции по изменению коллекции (add, set, remove) приводят к созданию новой копии внутреннего массива. Удобно использовать для частого чтения
    + ConcurrentHashMap<K, V> - В отличие от Hashtable и блоков synhronized на HashMap, данные представлены в виде сегментов, разбитых по hash'ам ключей. В результате, для доступ к данным лочится по сегментам, а не по одному объекту. В дополнение, итераторы представляют данные на определенный срез времени и не кидают ConcurrentModificationException
    + ConcurrentSkipListMap<K, V> - Является аналогом TreeMap с поддержкой многопоточности. Данные также сортируются по ключу и гарантируется усредненная производительность log(N) для containsKey, get, put, remove и других похожих операций
    
#### Queues
+ Неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.
    + Non-Blocking Queues
        + ConcurrentLinkedQueue<E> — В имплементации используется wait-free алгоритм от Michael & Scott, адаптированный для работы с garbage collector'ом. Этот алгоритм довольно эффективен и, что самое важное, очень быстр, т.к. построен на CAS. Метод size() может работать долго, т.ч. лучше постоянно его не дергать.
        + ConcurrentLinkedDeque<E> — Deque расшифровывается как Double ended queue и читается как «Deck». Это означает, что данные можно добавлять и вытаскивать с обоих сторон. Соответственно, класс поддерживает оба режима работы: FIFO (First In First Out) и LIFO (Last In First Out). На практике, ConcurrentLinkedDeque стоит использовать только, если обязательно нужно LIFO, т.к. за счет двунаправленности нод данный класс проигрывает по производительности на 40% по сравнению с ConcurrentLinkedQueue.
    + Blocking Queues
        + ArrayBlockingQueue<E> — Класс блокирующей очереди, построенный на классическом кольцевом буфере. Помимо размера очереди, доступна возможность управлять «честностью» блокировок. Если fair=false (по умолчанию), то очередность работы потоков не гарантируется.
        + LinkedBlockingQueue<E> — Блокирующая очередь на связанных нодах, реализованная на «two lock queue» алгоритме: один лок на добавление, другой на вытаскивание элемента. За счет двух локов, по сравнению с ArrayBlockingQueue, данный класс показывает более высокую производительность, но и расход памяти у него выше. Размер очереди задается через конструктор и по умолчанию равен Integer.MAX_VALUE.
        + PriorityBlockingQueue<E> — Является многопоточной оберткой над PriorityQueue. При вставлении элемента в очередь, его порядок определяется в соответствии с логикой Comparator'а или имплементации Comparable интерфейса у элементов. Первым из очереди выходит самый наименьший элемент.
        + SynchronousQueue<E> — Эта очередь работает по принципу один вошел, один вышел. Каждая операция вставки блокирует «Producer» поток до тех пор, пока «Consumer» поток не вытащит элемент из очереди и наоборот, «Consumer» будет ждать пока «Producer» не вставит элемент.
    
#### Synchronizers
+ Вспомогательные утилиты для синхронизации потоков, которые дают возможность разработчику регулировать и/или ограничивать работу потоков и предоставляют более высокий уровень абстракции, чем основные примитивы языка (мониторы)
    + Semaphore - Семафоры необходимы, когда нужно ограничить доступ к некоторому общему ресурсу. В конструктор этого класса (Semaphore(int permits) или Semaphore(int permits, boolean fair)) обязательно передается количество потоков, которому семафор будет разрешать одновременно использовать заданный ресурс
    + CountDownLatch - Предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определенное количество операций (счетчик уменьшаем методом CountDownLatch.countDown()), выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность. В конструктор CountDownLatch (CountDownLatch(int count)) обязательно передается количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.
    + CyclicBarrier - Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли они "отпускаются". Для указания потоку о том что он достиг барьера, нужно вызвать метод await()
    + Exchanger<V> - Обмен объектами между двумя потоками. Первый поток, который вызывает метод exchange(...) заблокируется до тех пор, пока тот же метод не вызовет второй поток. Как только это произойдет, потоки обменяются значениями и продолжат свою работу.
    + Phaser - Улучшенная реализация барьера для синхронизации потоков, которая совмещает в себе функционал CyclicBarrier и CountDownLatch
+ Подробно [тут](https://habr.com/ru/post/277669/)

#### Executors
+ Содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов.

#### Locks
+ Представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.

#### Atomics
+ Классы с поддержкой атомарных операций над примитивами и ссылками.
