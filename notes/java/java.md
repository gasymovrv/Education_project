# Java

### Java EE
1. Это просто набор спецификаций описанный в определенных стандартах:
    + **EJB** - Enterprise JavaBeans — спецификация технологии серверных компонентов, содержащих бизнес-логику
    + **JPA** - Java Persistence API — управление постоянством и объектно-реляционное отображение
    + **Servlet** - Обслуживание запросов веб-клиентов
    + **JSP** - JavaServer Pages — динамическая генерация веб-страниц на стороне сервера
    + **JSTL** - JavaServer Pages Standard Tag Library
    + **JSF** - JavaServer Faces — компонентный серверный фреймворк для разработки веб-приложений на технологии Java
    + **JAX-WS** - Java API for XML Web Services — создание веб-сервисов
    + **JAX-RS** - Java API for RESTful Web Services — создание RESTful веб-сервисов
    + **WebSocket** - Java API for WebSocket
    + **JSON-P** - Java API for JSON Processing — разбор и генерация JSON
    + **JSON-B** - Java API for JSON Binding — преобразование Java объектов в/из JSON
    + **JNDI** - Java Naming and Directory Interface — служба каталогов
    + **JMS** - Java Message Service — обмен сообщениями
    + **JTA** - Java Transaction API — управление транзакциями
    + **JAAS** - Java Authentication and Authorization Service — Java-реализация PAM	
    + **JavaMail** - Получение и отправка электронной почты
    + **JACC** - Java Authorization Contract for Containers
    + **JCA** - J2EE Connector Architecture
    + **JAF** - JavaBeans Activation Framework
    + **StAX** - Streaming API for XML
    + **CDI** - Context and Dependency Injection
    + **Validation** - Bean Validation
    + **Security** - Java EE Security API
1. В JDK есть интерфейсы и классы для использования этих стандартов
1. Реализация выполнена на серверах приложений (у каждого свой набор). Эталоным считается Glassfish, остальные расширяют его

### Методы Object
1. `int hashCode()` - возвращает хеш-код объекта
1. `boolean equals(Object obj)` - определяет, равен ли текущий объект другому
1. `Object clone()` - клонирует объект
1. `void finalize()` - вызывается перед удалением неиспользуемого объекта
1. `Class<?> getClass()` - получает класс объекта во время выполнения
1. `void notify()` - возобновляет выполнение потока, который ожидает вызывающего объекта
1. `void notifyAll()` - возобновляет выполнение всех потоков, которые ожидают вызывающего объекта
1. `String toString()` - возвращает строку, описывающую объект
1. `void wait()` - ожидает другого потока выполнения (есть перегрузки с параметром времени ожидания)

### Синтаксис Java
+ Наследование
+ Множественное насл-ие - в Java оно есть только для интерфейсов, что избавляет от проблемы совпадения имен методов
    + Совпадение имен методов в интерфейсах не приводит к проблемам, т.к. реализации они еще не имеют
    + Если совпадение имен произойдет с дефолтными методами, то программа не скомпилируется
+ Перегрузка - возвращаемые типы могут отлчиаться - это разные методы
+ Переопределение - возвращаемые типы могут сужаться, но не расширяться

### JVM компоненты
+ Classloader - загрузка классов из classpath
+ Garbage Collector - автоматическое управление памятью - heap (очень подробно [тут](https://habr.com/ru/post/269621/))
    + Serial - самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. Редко когда используется, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию.
    + Parallel - наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. Если на вашем компьютере больше одного процессорного ядра и вы явно не указали, какой сборщик хотите использовать в своей программе, то почти наверняка JVM остановит свой выбор на Parallel GC
    + CMS - нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти.
    + G1 - самый современный. Создан для постепенной замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных.
+ JIT-компилятор - динамическая компиляция байт кода в машинный код
+ компоненты управления потоками
+ и др.

+ Типы памяти
    + heap - хранятся объекты, чистится GC, общий на все приложение;
    + stack - хранятся локальные примитивы в методах и ссылки на объекты, чистится при завершении метода, потокобезопасен (отдельный стек на каждый поток)
    + Нативная память (состоит из нескольких областей) - классы, кэш JIT компилятора и др.
    
### Правила реализации equals/hashCode
+ `equals`:
    + Рефлексивность: Объект должен равняться себе самому.
    + Симметричность: если `a.equals(b) == true`, то `b.equals(a)` должен тоже быть `true`.
    + Транзитивность: если `a.equals(b) == true` и `b.equals(c) == true`, то `c.equals(a)` тоже должен быть `true`.
    + Согласованность: повторный вызов метода `equals()` должен возвращать одно и тоже значение, пока какое-либо значение свойств объекта не будет изменено
    + Сравнение с `null`: `a.equals(null)` должен вернуть `false`, а не NPE.
+ `hashcode`:
    + Должен использовать для вычисления те же поля что и `equals()`
    + У двух одинаковых объектов `hashcode` ДОЛЖЕН быть одинаковым
    + У двух разных объектов `hashcode` МОЖЕТ быть одинаковым (это коллизия, лучше чтобы такого не было)
+ Разное
    + Лучше делать объекты для ключей immutable, либо следует выбирать уникальные и не изменяющиеся во время жизни обьекта поля
    + Если hashcode не переопределить, то результат при работе с hash-коллекциями может быть непредсказуемым - будут добавляться одинаковые объекты (т.к. их хеши оказались разными) или не получится найти идентичный объект
    + Если hashcode сделать константой, то преимущество при работе с hash-коллекциями теряется, т.к. все элементы будут складываться в одну корзину

### Java Collections API
+ Производительность коллекций см. [algorithms.md](../algorithms.md)
+ Пояснения о работе HashMap   
	+ HashMap представляет из себя массив связных списков (корзин), дефолтный length которого = 16.
	+ Индекс вставки рассчитывается как ((length-1) & hash) - так всегда получается число в дипазаоне изначального length.
	    + где hash - это особый хеш из реализации HashMap на основе hashCode вставляемого ключа - гарантирует что коллизий будет не более 8 (элементов связного списка) с дефолтным capacity/loadfactor и правильным hashCode

	+ **put**:
	    + Вычислили индекс вставки
	    + Нашли корзину по этому индексу (если ее нет, то создали новую с этим элементом и на этом заканчиваем)
	    + Поочередно сравниваем хэши вставляемого элемента с хэшами элементов из корзины и если:
	    	+ Они идентичны. Далее проверяется equals:
	    	    + equals == true - значение элемента перезаписывается.
	    	    + equals == false - элемент добавялется в текущую корзину как новый элемент
	    	+ Они НЕ идентичны. Элемент добавялется в текущую корзину как новый элемент

	+ **get**:
        + Вычислили индекс вставки
        + Нашли корзину по этому индексу (если ее нет, то возвращаем NULL)
        + Поочередно сравниваем хэши искомого элемента с хэшами элементов из корзины и если:
            + Они идентичны. Далее проверяется equals:
                + equals == true - возвращаем ЭЛЕМЕНТ.
                + equals == false, то возвращаем NULL

    + Чем больше корзин, тем меньше коллизий - меньше итераций внутри корзин, но больше памяти потребуется (когда loadFactor меньше) 
    + Чем меньше корзин, тем больше коллизий - меньше памяти, но больше итераций при поиске. (когда loadFactor больше)

### Пул строк
+ Пул строк – это набор строк, который хранится в памяти Java heap (не точно, есть инфа что он хранится в отдельной области памяти)
+ Сам строковый пул возможен только потому, что строки в Java неизменные
+ Когда мы используем двойные кавычки для создания строки, сначала ищется строка в пуле с таким же значением, если находится, то просто возвращается ссылка, иначе создается новая строка в пуле, а затем возвращается ссылка. Тем не менее, создавая через ```new String("строка")```, мы можем принудительно создать новый объект
+ Метод intern()
    + Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка на строку из пула. 
    + В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.