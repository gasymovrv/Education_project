# Командная оболочка Bash (Linux)

## Ссылки
1. **СИМВОЛИЧЕСКИЕ ССЫЛКИ**
    + Символические ссылки более всего похожи на обычные ярлыки. Они содержат адрес нужного файла в вашей файловой системе. 
    Когда вы пытаетесь открыть такую ссылку, то открывается целевой файл или папка. 
    Главное ее отличие от жестких ссылок в том, что при удалении целевого файла ссылка останется, но она будет указывать в никуда, поскольку файла на самом деле больше нет.
    + Вот основные особенности символических ссылок:
        + Могут ссылаться на файлы и каталоги;
        + После удаления, перемещения или переименования файла становятся недействительными;
        + Права доступа и номер inode отличаются от исходного файла;
        + При изменении прав доступа для исходного файла, права на ссылку останутся неизменными;
        + Можно ссылаться на другие разделы диска;
        + Содержат только имя файла, а не его содержимое.
        
1. **ЖЕСТКИЕ ССЫЛКИ**
    + Этот тип ссылок реализован на более низком уровне файловой системы. 
    Файл размещен только в определенном месте жесткого диска. 
    Но на это место могут ссылаться несколько ссылок из файловой системы. 
    Каждая из ссылок - это отдельный файл, но ведут они к одному участку жесткого диска. 
    Файл можно перемещать между каталогами, и все ссылки останутся рабочими, поскольку для них неважно имя. 
    + Рассмотрим особенности:
        + Работают только в пределах одной файловой системы;
        + Нельзя ссылаться на каталоги;
        + Имеют ту же информацию inode и набор разрешений что и у исходного файла;
        + Разрешения на ссылку изменяться при изменении разрешений файла;
        + Можно перемещать и переименовывать и даже удалять файл без вреда ссылке.

## Основные команды Bash + Команды работы с файлами и директориями
1. **sudo** и **su**
    + ```su``` переключает вас в аккаунт root и требует пароля root. 
    + ```sudo``` запускает с привилегиями root одну команду - она не переключает вас в аккаунт суперпользователя и не требует отдельного пароля root.
    + ```sudo -i``` или ```sudo -s``` также как и ```su``` переключают на root
    + ```sudo -i -u root``` переключает на аккаунт с указанием имени
    + Только пользователи с администраторскими аккаунтами могут использовать ```sudo``` в Ubuntu.

1. **cd**
    + ```cd </path/to/directory>```
    + Сокращенное change directory. Позволяет перемещаться по файловой системе.
    + Путь может быть как абсолютным (начмнаться с /), так и относительным (подразумевается расположение пути относительно текущего).
    + cd без параметров перемещает в домашнюю директорию пользователя.
    + cd - перемещает по прошлому пути.
    + . (точка) текущая директория
    + .. (две точки) родительская директория
    + ~ (тильда) домашняя директория пользователя
    
1. **pwd**
    + ```pwd```
    + Cокращение от print work directory. Выводит текущий абсолютный путь.
    
1. **ls**
    + ```ls </path/to/directory>```
    + Сокращение от list. Отбражает все файлы и директории в директории </path/to/directory>.
    + ls без параметров отображает все файлы и директории по текущему пути
    + ls -a отображает скрытые файлы и папки
    + ls -l отображает расширенную информацию о файлах и папках
    
1. **cat**
    + ```cat <file_name>```
    + Отображает содержимое файла file_name.
    
1. **less**
    + ```less <file_name>```
    + Отображает содержимое файла file_name, выводит только содержимое помещающееся в окно терминала. 
    + Навигация по файлу возможна клавишами-стрелками, кнопка "q" закрывает просмотр.
    
1. **file**
    + ```file <file_name>```
    + Выводит на экран тип файла. Настоящий тип, а не указанный в расширении.
    
1. **cp**
    + ```cp <file1> <file2>```
    + Сокращение от copy. Копирует файл file1 по пути file2.

1. **mv**
    + ```mv file1 file2```
    + Сокращение от move.
    + Перемещает файл file1 по пути file2.

1. **rm**
    + ```rm <file1>```
    + Сокращение от remove.
    + Удаляет файл file1.
    + rm -r удаляет директорию
    
1. **mkdir**
   + ```  mkdir <directory>```
   + Сокращение от make directory.
   + Создает директории с именем directory.

1. **locate**
   + ```locate <file>```
   + Возвращает все пути с вхождениями file в них.

1. **man**
   + ```man <cmd>```
   + Отображает справку по команде cmd.

1. **echo**
   + ```echo <string>```
   + Выводит заданную строку string на экран.

1. **strings**
    + ```strings <file1>```
    + Выводит все строки с печатными символами из файла file1 на экран.

1. **tree**
    + ```tree```
    + показать дерево файлов и директорий, начиная от корня (/)

1. **>** и **>>** - перенаправление вывода
    + Bash позволяет перенаправлять стандартный вывод в файлы с помощью оператора >
    + Если файл не существовал, он будет создан, иначе он будет перезаписан.
    + ```echo hello! > 1.txt```
    + ```ls```
    + 1.txt
    + ```cat 1.txt```
    + hello!
    + Если требуется дописать строку в файл используется оператор >>.

1. **|** - конвейер
    + Если нужно перенаправить вывод одной команды на вход другой используется оператор |.
    + ```locate bin | less```

1. **grep** - поиск по содержимому файлов.
    + ```grep [opts] "pattern" file```
    + ```cat file | grep [opts] "pattern"```
    + opts:
    + -v - вывести строки, где не всречается образец
    + -i - игнорировать регистр символов
    + -n - печатать номера строк
    + -a - искать по бинарным файлам
    + -E - расширенные регулярные выражения
    + -o - вывести только совпадающую с образцом часть строки

1. **egrep** - тоже что и ```grep```, но работает с regex.
    + ```egrep [opts] "pattern" file```
    + ```cat file | egrep [opts] "pattern"```

1. **touch** - Обновляет время доступа и модификации файла.
    + ```touch hello-world``` - Создание пустого файла hello-world, если он не существовал.

1. **chmod** - изменение прав доступа к файлу.
    + Базовый синтаксис
        ```bash
        chmod <категория><действие><флаг> <имя файла>
        ```
        + Категория - флаги могут устанавливаться для трех категорий: владельца файла, группы файла и всех остальных пользователей. 
        В команде они указываются символами u (user) g (group) o (other) соответственно.
        + Действие - может быть + (плюс), что будет значить установить флаг или - (минус) снять флаг.
        + Флаг - один из доступных флагов - r (чтение), w (запись), x (выполнение).
    + Примеры
        ```bash
        chmod +rx filename # выдача прав на чтение/исполнение любому пользователю
        chmod u+rx filename # выдача прав на чтение/исполнение только "владельцу" скрипта
        chmod -rw filename # убираем права на чтение/запись любому пользователю
        ```

1. **chown** - изменение владельца файла или директории.
    + Базовый синтаксис
        ```bash
        chown [параметры] <имя владельца:имя группы владельцев> <имя файла или директории>
        ```
    + Примеры
        ```bash
        chown john picture.jp # Установка владельцем файла picture.jp пользователя john
        chown -R john . # Установка владельцем текущей директории и всех вложенных пользователя john
        ```

1. **history** - история команд.
    + Примеры
        ```bash
        history # Показать все выполненные команды 
        history 5 # Показать последние 5 команд
        history | grep docker # Показать последние команды, содержащие слово docker
        ```
    + Возвращает список пронумерованных команд:
        ```
        1 ls -la
        2 mkdir foo
        3 mv bar.txt foo
        ```
        + Их можно переиспользовать вызвав через `!<line_number>`. 
        + Например: `!1` - выполнит первую команду из истории - `ls -la`.
        
ПРИМЕРЫ:
+ ```cd -```	перейти в директорию, в которой находились до перехода в текущую директорию
+ ```pwd```	показать текущюю директорию
+ ```ls```	отобразить содержимое текущей директории
+ ```ls -l```	показать детализированое представление файлов и директорий в текущей директории
+ ```mkdir dir1```	создать директорию с именем 'dir1'
+ ```rm -f file1```	удалить файл с именем 'file1'
+ ```mv dir1 new_dir```	переименовать или переместить файл или директорию
+ ```cp file1 file2```	сопировать файл file1 в файл file2
+ ```cp dir/* .```	копировать все файлы директории dir в текущую директорию
+ ```cp -a /tmp/dir1 .```	копировать директорию dir1 со всем содержимым в текущую директорию
+ ```cp -a dir1 dir2```	копировать директорию dir1 в директорию dir2
+ ```ln -s file1 lnk1```	создать символическую ссылку на файл или директорию
+ ```touch -t 0712250000 filename```	модифицировать дату и время создания файла, при его отсутствии, создать файл с указанными датой и временем (YYMMDDhhmm)
+ ```find / -name file1```	найти файлы и директории с именем file1. Поиск начать с корня (/)
    
    
## Запуск командных/выполняемых/пакетных файлов
+ Создание/выполнение пакетного (командного) файла
    + Например, создадим файл с помощью ```echo``` с одной командой:
    ```
    echo 'echo the first parameter: $1' > shell_file.sh
    ```
    + Выполним этот файл:
    ```
    sh shell_file.sh
    ```
    + Первой строкой в таких файлах должен идти так называемый шебанг (сейчас многие терминалы уже работают и без него)
    ```
    #!/bin/bash
    ```
+ Создание/выполнение исполняемого файла
    + Берем предыдущий файл и вызываем с командой ```chmod +x```:
    ```
    chmod +x shell_file.sh
    ```
    + Вызываем на исполнение
    ```
    ./shell_file param1
    ```
    
    
## Команды для использования в пакетных файлах, передача параметров в пакетный файл
1. **Передача параметров в пакетный файл:**
    + ```$1```, ```$2``` - доступ к 1му, 2му и т.д. параметрам
    + ```$#``` - количество параметров с которыми вызван файл
    + ```$*``` - все параметры через пробел с которыми вызван файл

1. **Переменные**
   + Имя переменной может начинаться с буквы или символа подчереркивания
   знак равенства(=) это оператор присваиивания
       ```bash
       _var=1
       _word =slovo
       value="t ak aia dli nna iain epo niat naia str oka"
       ```
   
   + Тип данных переменных shell это всегда строка символов! (заранее создан исполняемый файл sample)
       ```bash
       $ cat sample
       _string="Hello from Perm"
       echo $_string
       #или так на случай если пишем переменную в тексте:
       ${_string}
       ```
       ```bash
       $ /home/sgww/sample
       Hello from Perm
       ```
   
   + Результат выполения команды в переменную (команда обрамляется обратными апострофами)
       ```bash
       $ cat sample
       _date=`date`
       echo $_date
       ```
       ```bash
       $ /home/sgww/sample
       Tue Mar 2 11:41:30 YEKT 201
       ```
  
   + Ввод значения переменной в консоли
       ```bash
       $ cat sample
       echo Enter data:
       read data1
       read data2
       echo Your data:  $data1 and  $data2
       ```
       ```bash
       $ /home/sgww/sample
       Enter data:
       Linux
       Windows
       Your data: Linux and Windows
       ```
   
1. **Системные переменные**
    + PATH - пути поиска исполняемых файлов (так как каталога /home/sgww/ там нет, постояно приходилось писать полный путь /home/sgww/sample для выполнения команды)
    + HOME - домашний каталог
    + MAIL - файл электронной почты
    + SHELL - оболочка в которой работаем 
        
        ```$ cat sample```
        ```bash
        echo $PATH
        echo $HOME
        echo $MAIL
        echo $SHELL
        ```
        ```$ /home/sgww/sample```
        ```bash
        /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games
        /home/sgww
        /var/mail/sgww
        /bin/bash
        ```

    + Добавим к переменной PATH каталог HOME что бы не приходилось постоянно писать полный путь
        ```
        PATH=$PATH:$HOME
        ```
        + Если это прописать прямо в консоли, то после перезапуска оно сотрется. Чтобы навсегда надо добавить в ```~/.profile```

1. **Специальные символы**
    + ```*``` - любая последовательность, любых символов
    + ```?``` - один любой символ
    + ```[...]``` - любой из символов диапазона
    + Двойные кавычки ``` "" ```
        + Одиночный символ * означает любое имя файла в заданном каталоге
        ```bash
        $echo *
        cpp file.txt mydaemon net_sh perl php sample
        $ echo "*"
        *
        ```
    + Апострофы ``` '' ```
        ```bash
        $ cat sample
        text="This is a text"
        echo '$text'
        $ sample
        $text
        ```
    + Обратный слэш ``` \ ```
        ```bash
        $ cat sample
        text="This is a text"
        echo \$text
        $ sample
        $text
        ```
    + Обратный апостроф ``` `` ```
        ```bash
        $ cat sample
        text=`pwd`
        echo $text
        $ sample
        /home/sgww
        ```

1. **Арифметические операции**
    + Для выполнения арифметических операций в командном файле понадобиться команда ```expr```
        ```bash
        $ expr 7 + 96
        103
        $ expr 87 - 555
        -468
        $  expr 18 / 2
        9
        $ expr 19 / 2
        9
        $ expr 19 % 2
        1
        $ expr 6 \* 32
        192
        $ expr 6 '*' 32
        192
        $ expr 6 * 32
        expr: syntax error
        ```
        + Если при умножении не поставить  \ или ' ' то *, будет восприниматься как любой символ
        + Стоит отметить, что / - это не деление, а целая часть от деления, операция % дает остаток от деления
    + Пример
        ```bash
        $ cat sample
        read x
        read y
        echo `expr $x '*' $y + 7`
        $ sample
        4
        5
        27
        ```
   
1. **Переменные окружения, команда export и unset**
    + Для взаимодейстивя с другими процессами могут пригодиться переменные окружения
    + Их полный списко можно посмотреть командой export
        ```bash
        $ export
        declare -x HISTCONTROL="ignoreboth"
        declare -x HOME="/home/sgww"
        declare -x LESSCLOSE="/usr/bin/lesspipe %s %s"
        declare -x LESSOPEN="| /usr/bin/lesspipe %s"
        declare -x LOGNAME="sgww"
        ...
        ```
    + Задать свою переменную
        ```bash
        $ name=Pavel && export name
        $ echo $name
        Pavel
        ```
    + Удалить
        ```bash
        $ unset name
        $ echo name
        ```
    
1. **Условие IF**
    + Команда ```test``` (или ```[ ]```).
    + Команда test проверяет выполнение некоторого условия. С использованием этой (встроенной) команды
    формируются операторы выбора и циклы.
    + Есть два возможных формата команды:
        ```bash
        test условие
        ```
        или
        ```bash
        [ условие ]
        ```
        + Между скобками и содержащимся в них условием обязательно должны быть пробелы.
    + Условия проверки файлов:
        + ```-f имя``` Файл ```имя``` является обычным (регулярным) файлом.
        + ```-d имя``` Файл ```имя``` - папка.
        + ```-L имя``` Файл ```имя``` - символьная ссылка.
        + ```-r имя``` Имеется разрешение на чтение файла ```имя```.
        + ```-w имя``` Имеется разрешение на запись в файл ```имя```.
        + ```-x имя``` Имеется разрешение на выполнение файла ```имя```.
        + ```-s имя``` Файл ```имя``` не пустой.
    + Условия проверки строк:
        + ```str1 = str2``` Строки "str1" и "str2" совпадают.
        + ```str1 != str2``` Строки "str1" и "str2" не совпадают.
        + ```-n str1``` Строка "str1" существует (непустая).
        + ```-z str1``` Строка "str1" не существует (пустая, имеет нулевую длину).
    + Условия сравнения целых чисел:
        + ```x -eq y``` x = y
        + ```x -ne y``` x не равно y
        + ```x -gt y``` x > y
        + ```x -ge y``` x >= y
        + ```x -lt y``` x < y
        + ```x -le y``` x <= y
    + Объединение и отрицание при проверке.
        + ```t1 -a t2``` Логическое И.
        + ```t1 -o t2``` Логическое ИЛИ.
        + ```! t1``` Отрицание.
    + Пример
        ```bash
        if [ "$age" -ge 18 ]
        then
         echo You are grownup.
        else
         echo You are juvenile.
        fi
        ```
        ```bash
        if [ -z $1 ]
        then echo There must be two params. No one param specified. Re-enter with two params.
        elif [ -z $2 ]
        then echo There must be two params. One param specified only. Re-enter with two params.
        elif [ $1 -lt $2 ]
        then echo The \"$1\" param is less than the \"$2\" param.
        elif [ $1 -gt $2 ]
        then echo The \"$1\" param is greater than the \"$2\" param.
        elif [ $1 -eq $2 ]
        then echo Both params are equal.
        else echo Values cannot be compared.
        fi
        ```
1. **Оператор выбора Case**
    + Оператор выбора имеет структуру:
        ```bash
        case строка-образец in
        строка-шаблон) 
        список команд
        ;;
        строка-шаблон) 
        список команд
        ;;
        ...
        esac
        ```
    + Пример
        ```bash
        echo "Выберите редактор для запуска:"
        echo "1 Запуск программы nano"
        echo "2 Запуск программы vi"
        echo "3 Запуск программы emacs"
        echo "4 Выход"
        read doing #здесь мы читаем в переменную $doing со стандартного ввода
        
        case $doing in
        1)
        /bin/nano # если $doing содержит 1, то запустить nano
        ;;
        2)
        /bin/vi # если $doing содержит 2, то запустить vi
        ;;
        3)
        /bin/emacs # если $doing содержит 3, то запустить emacs
        ;;
        4)
        exit 0
        ;;
        *) #если введено с клавиатуры то, что в case не описывается, выполнять следующее:
        echo "Введено неправильное действие"
        esac
        ```

1. **Цикл FOR**
    + Пример 1
        ```bash
        $ cat sample
        for x in  1 two 3
        do
         echo $x
        done
        
        $ sample
        1
        two
        3
        ```
        + В этом цикле код между do и done выполнится 3 раза, при этом первый раз
        x=1, второй раз x=two и последний x=3
    
    + Пример 2
        ```bash
        $ cat sample
        for x in *
        do
         echo $x
        done
        
        $ sample
        cpp
        demo
        file.txt
        mydaemon
        net_sh
        perl
        php
        sample
        ```
        + ```*``` в списке переменных цикла, заставляет for использовать в качестве значения $x элементы текущего каталога
    + Пример 3
        ```bash
        FILES=/Users/username/dev/*
        for file in $FILES
        do
           echo $(basename $file) # basename Выводит имя файла без пути с папками.
        done
        ```
    + Пример 4
        ```bash
        for (( count=1; count<5; count++ ))
        do
        echo "$count"
        done
        
        $ sample
        1
        2
        3
        4
        ```

1. **Циклы WHILE и UNTIL**
    + Пример цикла ```WHILE``` от 0 до 10
        ```bash
        count=0
        while [ $count -lt 10 ]
        do
        (( count++ ))
        echo $count
        done
        ```
    
    + Пример бесконечного цикла ```WHILE```
        ```bash
        while [ 1 = 1 ]
        do
        (( count++ ))
        echo $count
        sleep 0.1 #ожидание 100мс
        done
        ```
    + Аналогично, но «в обратную сторону» работает и цикл ```UNTIL```:
        ```bash
        until [ $count -gt 10 ]
        do
        (( count++ ))
        echo $count
        done
        ```

1. **Функции**
    + Варианты синтаксиса:
        ```bash
        function one {
          echo "One"
        }
        ```
        ```bash
        two () {
          echo "Two"
        }
        ```
        ```bash
        function three () {
          echo "Three"
        }
        ```
    + Использование:
        ```bash
        one
        two
        three
        ```
    + Аргументы
        ```bash
        printstr(){
        echo $1
        echo $2
        echo $3
        echo $5
        }
        printstr "arg1" "arg2" "arg3" "arg4" "arg5"
        
        # Или со сдвигом указателя стэка:
        printstr(){
        echo $1
        shift
        echo $1
        shift
        echo $1
        shift
        echo $1
        }
        printstr "arg1" "arg2" "arg3" "arg4"
        ```

## Работа с процессами
1. ```ps```
    + Предназначена для вывода информации о выполняемых процессах. 
    + Наиболее часто используемые параметры:
        + ```-a```	отобразить все процессы, связанных с терминалом (отображаются процессы всех пользователей)
        + ```-e```	отобразить все процессы
        + ```-t список терминалов```	отобразить процессы, связанные с терминалами
        + ```-u идентификаторы пользователей```	отобразить процессы, связанные с данными идентификаторыми
        + ```-g идентификаторы групп```	отобразить процессы, связанные с данными идентификаторыми групп
        + ```-x```	отобразить все процессы, не связанные с терминалом
    + Чтобы посмотреть все активные на данный момент процессы в linux, используется сочетание опций ```aux```
        ```
        ps aux
        ```
    + Пример сортировки по полю ```%MEM```:
        ```
        ps aux --sort=%mem
        ```
1. ```top```
    + Предназначена для вывода информации о процессах в реальном времени. 
    Процессы сортируются по максимальному занимаемому процессорному времени, но вы можете изменить порядок сортировки (см. man top). 
    Программа также сообщает о свободных системных ресурсах. 
    + Своего рода терминальный «Системный монитор».
1. ```kill```
    + Эта команда служит для принудительного завершения процессов. 
    + Нужно ввести kill PID_процесса. PID процесса можно узнать, введя ```top```.
    + Пример:
    ```
    kill 1234
    ```
1. ```xkill```
    + Ещё одна команда для завершения процессов. Введите её, затем щёлкните по тому окну, которое нужно закрыть.
1. ```killall```
    + Убивает процессы c определённым именем. К примеру, ```killall firefox```.

