# Командная оболочка Bash (Linux)


## Основные команды Bash + Команды работы с файлами и директориями
1. **cd**
    + ```cd </path/to/directory>```
    + Сокращенное change directory. Позволяет перемещаться по файловой системе.
    + Путь может быть как абсолютным (начмнаться с /), так и относительным (подразумевается расположение пути относительно текущего).
    + cd без параметров перемещает в домашнюю директорию пользователя.
    + cd - перемещает по прошлому пути.
    + . (точка) текущая директория
    + .. (две точки) родительская директория
    + ~ (тильда) домашняя директория пользователя
    
1. **pwd**
    + ```pwd```
    + Cокращение от print work directory. Выводит текущий абсолютный путь.
    
1. **ls**
    + ```ls </path/to/directory>```
    + Сокращение от list. Отбражает все файлы и директории в директории </path/to/directory>.
    + ls без параметров отображает все файлы и директории по текущему пути
    + ls -a отображает скрытые файлы и папки
    + ls -l отображает расширенную информацию о файлах и папках
    
1. **cat**
    + ```cat <file_name>```
    + Отображает содержимое файла file_name.
    
1. **less**
    + ```less <file_name>```
    + Отображает содержимое файла file_name, выводит только содержимое помещающееся в окно терминала. 
    + Навигация по файлу возможна клавишами-стрелками, кнопка "q" закрывает просмотр.
    
1. **file**
    + ```file <file_name>```
    + Выводит на экран тип файла. Настоящий тип, а не указанный в расширении.
    
1. **cp**
    + ```cp <file1> <file2>```
    + Сокращение от copy. Копирует файл file1 по пути file2.

1. **mv**
    + ```mv file1 file2```
    + Сокращение от move.
    + Перемещает файл file1 по пути file2.

1. **rm**
    + ```rm <file1>```
    + Сокращение от remove.
    + Удаляет файл file1.
    + rm -r удаляет директорию
    
1. **mkdir**
   + ```  mkdir <directory>```
   + Сокращение от make directory.
   + Создает директории с именем directory.

1. **locate**
   + ```locate <file>```
   + Возвращает все пути с вхождениями file в них.

1. **man**
   + ```man <cmd>```
   + Отображает справку по команде cmd.

1. **echo**
   + ```echo <string>```
   + Выводит заданную строку string на экран.

1. **strings**
    + ```strings <file1>```
    + Выводит все строки с печатными символами из файла file1 на экран.

1. **tree**
    + ```tree```
    + показать дерево файлов и директорий, начиная от корня (/)

1. **>** и **>>** - перенаправление вывода
    + Bash позволяет перенаправлять стандартный вывод в файлы с помощью оператора >
    + Если файл не существовал, он будет создан, иначе он будет перезаписан.
    + ```echo hello! > 1.txt```
    + ```ls```
    + 1.txt
    + ```cat 1.txt```
    + hello!
    + Если требуется дописать строку в файл используется оператор >>.

1. **|** - конвейер
    + Если нужно перенаправить вывод одной команды на вход другой используется оператор |.
    + ```locate bin | less```

1. **grep** - поиск по содержимому файлов (работает и с regex)
    + ```grep [opts] "pattern" file```
    + ```cat file | grep [opts] "pattern"```
    + opts:
    + -v - вывести строки, где не всречается образец
    + -i - игнорировать регистр символов
    + -n - печатать номера строк
    + -a - искать по бинарным файлам
    + -E - расширенные регулярные выражения
    + -o - вывести только совпадающую с образцом часть строки

1. **egrep** - тоже что и ```grep```, но работает с regex быстрее
    + ```egrep [opts] "pattern" file```
    + ```cat file | egrep [opts] "pattern"```
    + pattern - регулярное выражение

ПРИМЕРЫ:
+ ```cd -```	перейти в директорию, в которой находились до перехода в текущую директорию
+ ```pwd```	показать текущюю директорию
+ ```ls```	отобразить содержимое текущей директории
+ ```ls -l```	показать детализированое представление файлов и директорий в текущей директории
+ ```mkdir dir1```	создать директорию с именем 'dir1'
+ ```rm -f file1```	удалить файл с именем 'file1'
+ ```mv dir1 new_dir```	переименовать или переместить файл или директорию
+ ```cp file1 file2```	сопировать файл file1 в файл file2
+ ```cp dir/* .```	копировать все файлы директории dir в текущую директорию
+ ```cp -a /tmp/dir1 .```	копировать директорию dir1 со всем содержимым в текущую директорию
+ ```cp -a dir1 dir2```	копировать директорию dir1 в директорию dir2
+ ```ln -s file1 lnk1```	создать символическую ссылку на файл или директорию
+ ```touch -t 0712250000 fileditest```	модифицировать дату и время создания файла, при его отсутствии, создать файл с указанными датой и временем (YYMMDDhhmm)
+ ```find / -name file1```	найти файлы и директории с именем file1. Поиск начать с корня (/)
    
    
## Запуск командных/выполняемых/пакетных файлов
+ Создание/выполнение пакетного (командного) файла
    + Например, создадим файл с помощью ```echo``` с одной командой:
    ```
    echo 'echo the first parameter: $1' > shell_file.sh
    ```
    + Выполним этот файл:
    ```
    sh shell_file.sh
    ```
+ Создание/выполнение исполняемого файла
    + Исполняемые файлы создаются командой chmod
    + ```chmod категория действие флаг адрес_файла```
        + Категория - флаги могут устанавливаться для трех категорий: владельца файла, группы файла и всех остальных пользователей. 
        В команде они указываются символами u (user) g (group) o (other) соответственно.
        + Действие - может быть + (плюс), что будет значить установить флаг или - (минус) снять флаг.
        + Флаг - один из доступных флагов - r (чтение), w (запись), x (выполнение).
    + Берем предыдущий файл и вызываем с командой ```chmod +x```:
    ```
    chmod +x shell_file.sh
    ```
    + Вызываем на исполнение
    ```
    ./shell_file param1
    ```
    
    
## Команды для использования в пакетных файлах, передача параметров в пакетный файл
1. **Передача параметров в пакетный файл:**
    + ```$1```, ```$2``` - доступ к 1му, 2му и т.д. параметрам
    + ```$#``` - количество параметров с которыми вызван файл
    + ```$*``` - все параметры через пробел с которыми вызван файл
1. **Переменные**
   
   Имя переменной может начинаться с буквы или символа подчереркивания
   знак равенства(=) это оператор присваиивания
   
   _var=1
   _word =slovo
   value="t ak aia dli nna iain epo niat naia str oka"
   
   Тип данных переменных shell это всегда строка символов!
   
   $ cat sample
   _string="Hello from Perm"
   echo $_string
   $ /home/sgww/sample
   Hello from Perm
   
   результат выполения команды в переменную (команда обрамляется обратными апострофами)
   
   $cat sample
   _date=`date`
   echo $_date
   $/home/sgww/sample
   Tue Mar 2 11:41:30 YEKT 201
   
   ввод значения переменной в консоли
   
   $ cat sample
   echo Enter data:
   read data1
   read data2
   echo Your data:  $data1 and  $data2
   $ /home/sgww/sample
   Enter data:
   Linux
   Windows
   Your data: Linux and Windows
   
1. **Системные переменные**
   
   $ cat sample
   echo $PATH
   echo $HOME
   echo $MAIL
   echo $SHELL
   $ /home/sgww/sample
   /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games
   /home/sgww
   /var/mail/sgww
   /bin/bash
   
   PATH - пути поиска исполняемых файло (так как каталога /home/sgww/ там нет, постояно приходилось писать полный путь /home/sgww/sample для выполнения команды)
   HOME - домашний каталог
   MAIL - файл электронной почты
   SHELL - оболочка в которой работаем 
   
   Добавим к переменной PATH каталог HOME что бы не приходилось постоянно писать полный путь
   
   $ cat sample
   PATH=$PATH:$HOME
   Эти строки следует добавить в ~/.profile или ~/.bash_profile
   теперь нет необходимости писать полный путь до команды 
   
1. **Специальные символы**
   
   * - любая последовательность, любых символов
   ? - один любой символ
   [...] - любой из символов диапазона
   
   Двойные кавычки ""
   
   $echo *
   cpp file.txt mydaemon net_sh perl php sample
   $ echo "*"
   *
   
   Апострофы ''
   
   
   $ cat sample
   text="This is a text"
   echo '$text'
   $ sample
   $text
   
   Обратный слэшь \
   
   $ cat sample
   text="This is a text"
   echo \$text
   $ sample
   $text
   
   Обратный апостроф ``
   
   $ cat sample
   text=`pwd`
   echo $text
   $ sample
   /home/sgww
   
1. **Арифметические операции**
   
   Для выполнения арифметических операций в командном файле понадобиться команда expr
   
   $ expr 7 + 96
   103
   $ expr 87 - 555
   -468
   $  expr 18 / 2
   9
   $ expr 19 / 2
   9
   $ expr 19 % 2
   1
   $ expr 6 \* 32
   192
   $ expr 6 '*' 32
   192
   $ expr 6 * 32
   expr: syntax error
   
   
   Если при умножении не поставить  \ или '' то * будет восприниматься как любой символ
   
   Стоит отметить, что \ - это не деление, а целая часть от деления, операция % дает остаток от деления
   
   $ cat sample
   read x
   read y
   echo `expr $x '*' $y + 7`
   $ sample
   4
   5
   27
   
1. **Переменные окружения, команда export и unset**
   
   Для взаимодейстивя с другими процессами могут пригодияться переменные окружения
   
   Их полный списко можно посмотреть командой export
   
   $ export
   declare -x HISTCONTROL="ignoreboth"
   declare -x HOME="/home/sgww"
   declare -x LESSCLOSE="/usr/bin/lesspipe %s %s"
   declare -x LESSOPEN="| /usr/bin/lesspipe %s"
   declare -x LOGNAME="sgww"
   ...
   
   Задать свою переменную
   
   $ name=Pavel && export name
   $ echo $name
   Pavel
   
   Удалить
   
   $ unset name
   $ echo name
   
1. **Условие IF**
   
   Для составления условных выражений оператора if очень полезна программа test.
   
   $ cat sample
   if test -r sample
   then
      echo True
   else
      echo False
   fi
   $ sample
   True
   
   В этом примере test -r sample - это условие
   echo True выполняется если условие истино
   echo False если ложно
   
   Программа test предназначена для проверки типов файлов и сравнения значений
   
   $test -r file # Истино если файл file существует и доступен для чтения
   $test -w file # Истино если файл file существует и доступен для записи
   $test -x file # Истино если файл file существует и доступен для выполнения
   
   $ x=32 && export x
   $ y=32 && export y
   
   $test $x -eq $y # Истино если $x равен $y
   $test $x -en $y # Истино если $x не равен $y
   $test $x -ge $y # Истино если $x больше или равен $y
   $test $x -gt $y # Истино если $x больше $y
   $test $x -le $y # Истино если $x меньше или равен $y
   $test $x -lt $y # Истино если $x меньше $y
   
   Остальные параметры можно посмотреть в man test
   
1. **Цикл FOR**
   
   $ cat sample
   for x in  1 two 3
   do
    echo $x
   done
   $ sample
   1
   two
   3
   
   В этом цикле код между do и done выполниться 3 раза, при этом первый раз
   x=1, второй раз x=two и последний x=3
   
   Другой интересный пример
   
   $ cat sample
   for x in *
   do
    echo $x
   done
   $ sample
   cpp
   demo
   file.txt
   mydaemon
   net_sh
   perl
   php
   sample
   
   * в списке переменных цикла, заставляет for использовать в качестве значения $x элементы текущего каталога
   
1. **Циклы WHILE и UNTIL**
   
   $ cat sample
   while test -r file
   do
    sleep 10
    echo file exists
   done
   echo file does not exist
   
   $ touch file
   $ sample
   file exists
   file exists
   Ctr+Z
   [1]+  Stopped                 sample
   $ rm file
   $ fg
   sample
   file exists
   file does not exist
   
   
   $ cat sample
   until test -r file
   do
   sleep 5
   echo file does not exist
   done
   echo file exists
   $ sample
   file does not exist
   file does not exist
   Ctr+Z
   [1]+  Stopped                 sample
   $ touch file
   $ fg
   sample
   file does not exist
   file exists
   $


## Работа с процессами
1. ```kill```
    + Эта команда служит для принудительного завершения процессов. 
    + Нужно ввести kill PID_процесса. PID процесса можно узнать, введя ```top```.
1. ```xkill```
    + Ещё одна команда для завершения процессов. Введите её, затем щёлкните по тому окну, которое нужно закрыть.
1. ```killall```
    + Убивает процессы c определённым именем. К примеру, killall firefox.
1. ```top```
    + Отображает перечень запущенных процессов, сортируя в зависимости от потребления ресурсов CPU. 
    + Своего рода терминальный «Системный монитор».
