let lg = console.log.bind(console);


//-----------------------------------------------Регулярные выражения----------------------------------------------
//  Флаги
// i - Если этот флаг есть, то регэксп ищет независимо от регистра, то есть не различает между А и а.
// g - Если этот флаг есть, то регэксп ищет все совпадения, иначе – только первое.
// m - Многострочный режим.


//-------------------- str.search(reg) --------------------
//str.search(reg) - возвращает индекс найденного совпадения по рег. выражению reg
//всегда ищет только первое совпадение.
var str = "Я люблю JavaScript!"; // будем искать в этой строке
lg( str.search( /ЛЮ/ ) ); // -1
lg( str.search( /ЛЮ/i ) ); // 2


//-------------------- str.match(reg) --------------------
//str.match(reg) без флага g находит только одно, первое совпадение.
//Результат вызова – это массив, состоящий из этого совпадения, с дополнительными свойствами:
// index – позиция, на которой оно обнаружено и
// input – строка, в которой был поиск.
// Если match не нашёл совпадений, он возвращает не пустой массив, а именно null.
var str = "ОЙ-Ой-ой";
var result = str.match( /ой/i );
lg( result[0] ); // ОЙ  (совпадение)
lg( result.index ); // 0 (позиция)
lg( result.input ); // ОЙ-Ой-ой (вся поисковая строка)

//str.match(reg) со скобочной группой
var str = "javascript - это такой язык";
var result = str.match( /JAVA(SCRIPT)/i );
lg( result[0] ); // javascript (всё совпадение полностью)
lg( result[1] ); // script (часть совпадения, соответствующая скобкам)
lg( result.index ); // 0
lg( result.input ); // javascript - это такой язык

//str.match(reg) с флагом g
//Никаких дополнительных свойств у массива в этом случае нет, скобки дополнительных элементов не порождают.
var str = "ОЙ-Ой-ой";
var result = str.match( /ой/ig );
lg( result[0] ); // ОЙ
lg( result[1] ); // Ой
lg( result[2] ); // ой
lg( result.index ); // undefined
lg( result.input ); // undefined


//-------------------- str.replace(reg, str|func) --------------------
//В строке для замены можно использовать специальные символы:
//Спецсимволы	Действие в строке замены
//  $$	        Вставляет "$".
//  $&	        Вставляет всё найденное совпадение.
//  $`	        Вставляет часть строки до совпадения.
//  $'	        Вставляет часть строки после совпадения.
//  $*n*	    где n -- цифра или двузначное число, обозначает n-ю по счёту скобку, если считать слева-направо.
var str = "Василий Пупкин";
lg(str.replace(/(Василий) (Пупкин)/, '$2, $1')); // Пупкин, Василий

//Выделяем тегом <strong> повторяющиеся слова (только латиница)
// \1 - это использование первой скобочной группы
var str = 'This test test is is';
lg(str.replace(/(\w+)(\s+)(\1)/gi, '$1$2<strong>$3</strong>'));

//Выделяем тегом <strong> повторяющиеся слова
// \2 - это использование второй скобочной группы
var str = "Этот тест тест для для This test Test is is всё всЁ";
lg(str.replace(/(^|\s+)([\wа-яё]+)(\s+)(\2)/gi, '$1$2$3<strong>$4</strong>'));


// Функция вместо строки замены в функции replace
//Эта функция получает следующие аргументы:
//  str – найденное совпадение,
//  p1, p2, ..., pn – содержимое скобок (если есть),
//  offset – позиция, на которой найдено совпадение,
//  s – исходная строка.

// вывести и заменить все совпадения
function replacer(str, offset, s) {
    lg( "Найдено: " + str + " на позиции: " + offset + " в строке: " + s );
    return 'вай';
}
var result = "ОЙ-Ой-ой".replace(/ой/gi, replacer);
lg( 'Результат: ' + result ); // Результат: вай-вай-вай

//С двумя скобочными выражениями – аргументов уже 5:
function replacer(str, name, surname, offset, s) {
    return surname + ", " + name;
}
var str = "Василий Пупкин";
lg(str.replace(/(Василий) (Пупкин)/, replacer)) // Пупкин, Василий


//-------------------- regexp.test(str) --------------------
//Метод test проверяет, есть ли хоть одно совпадение в строке str. Возвращает true/false.
//Работает, по сути, так же, как и проверка str.search(reg) != -1, например:
var str = "Люблю регэкспы я, но странною любовью";
// эти две проверки идентичны
lg( /лю/i.test(str) ); // true
lg( str.search(/лю/i) !== -1 ); // true


//-------------------- regexp.exec(str) --------------------
//Если флага g нет, то regexp.exec(str) ищет и возвращает первое совпадение,
//  является полным аналогом вызова str.match(reg).
//Если флаг g есть,
//  то вызов regexp.exec возвращает первое совпадение и запоминает его позицию в свойстве regexp.lastIndex.
//  Последующий поиск он начнёт уже с этой позиции.
//  Если совпадений не найдено, то сбрасывает regexp.lastIndex в ноль.
var str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';
var regexp = /javascript/ig;
var result  = regexp.exec(str);
lg( "Начальное значение lastIndex: " + regexp.lastIndex );
while (result) {
    lg( 'Найдено: ' + result[0] + ' на позиции:' + result.index );
    lg( 'Свойство lastIndex: ' + regexp.lastIndex );
    result  = regexp.exec(str);
}
lg( 'Конечное значение lastIndex: ' + regexp.lastIndex );

//Можно заставить regexp.exec искать сразу с нужной позиции, если поставить lastIndex вручную:
var str = 'Многое по JavaScript можно найти на сайте http://javascript.ru';
var regexp = /javascript/ig;
regexp.lastIndex = 40;
alert( regexp.exec(str).index ); // 49, поиск начат с 40-й позиции



//-------------------- Примеры с классами: \d \s \w \b \S и т.д. --------------------
var str = "Многое по Ja2vaScript мож2но найти н3а сайте h_tt1p://java4script.ru";
var result = str.match( /\d/ig );
if(result){
    result.forEach((el, i)=>{lg(`${i} = `,el);})
}
//0 =  2
//1 =  2
//2 =  3
//3 =  1
//4 =  4

var str = "Многое по Ja2vaScript мож2но найти н3а сайте h_tt1p://java4script.ru";
var result = str.match( /\s*\S+\s*/ig );
if(result){
    result.forEach((el, i)=>{lg(`${i} = `,el);})
}
// 0 =  Многое
// 1 =  по
// 2 =  Ja2vaScript
// 3 =  мож2но
// 4 =  найти
// 5 =  н3а
// 6 =  сайте
// 7 =  h_tt1p://java4script.ru

var str = "Многое по Ja2vaScript мож2но найти н3а сайте h_tt1p://java4script.ru";
var result = str.match( /\b\w+\b/ig );
if(result){
    result.forEach((el, i)=>{lg(`${i} = `,el);})
}
// 0 =  Ja2vaScript
// 1 =  2
// 2 =  3
// 3 =  h_tt1p
// 4 =  java4script
// 5 =  ru

// регулярное выражение для поиска времени в строке: Завтрак в 09:00.
var str = 'Завтрак в 09:00';
var result = str.match( /\d\d:\d\d/ig );
if(result){
    result.forEach((el, i)=>{lg(`${i} = `,el);})
}
// 0 = 09:00


//-------------------- Наборы и диапазоны [...] --------------------
// найти [г или т], а затем "оп"
lg( "Гоп-стоп".match(/[гт]оп/gi) ); // "Гоп", "топ"

//Ищем слова на русском и на латинице
var str = "Солнце (the sun) встаёт!";
//Буква ё лежит в стороне от основной кириллицы и её следует добавить в диапазон дополнительно
lg( str.match(/[a-zа-яё]+/gi) ); // Солнце, the, sun, встаёт
//или
lg( str.match(/[\wа-яё]+/gi) ); // Солнце, the, sun, встаёт

//Напишите регулярное выражение для поиска времени:
var re = /\d\d[:-]\d\d/g;
lg( "Завтрак в 09:00. Обед - в 21-30".match(re) ); // 09:00, 21-30