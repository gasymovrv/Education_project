//---------------------------------------------------Базовые понятия----------------------------------------------









//---------------------------------------------------Функции----------------------------------------------


//-----------------------------------------------------

// Function Declaration
function sum1(a, b) {
    return a + b;
}

// Function Expression
var sum2 = function(a, b) {
    return a + b;
};


//Named Function Expression----------------------------

//Попробуем перенести функцию в другую переменную g:
function f(n) {
    return n ? n * f(n - 1) : 1;
}
var g = f;
f = null;
alert( g(5) ); // запуск функции с новым именем - ошибка при выполнении!
//Ошибка возникла потому что функция из своего кода обращается к своему старому имени f.
//А этой функции уже нет, f = null.


//Для того, чтобы функция всегда надёжно работала, объявим её как Named Function Expression:
var f1 = function factorial(n) {
    return n ? n * factorial(n - 1) : 1;
};
var g1 = f1;  // скопировали ссылку на функцию-факториал в g
f1 = null;

alert(g1(5)); // 120, работает!











//---------------------------------------------------Объекты----------------------------------------------


//--------------------Поля (свойства)---------------------
var person = {
    name: "Василий"
};
alert(person.lalala === undefined); // true, свойства нет
alert( person.name === undefined ); // false, свойство есть.
delete person.name; //удаляем поле
alert( person.name === undefined ); // true, теперь свойства нет

//более правлильно проверять наличие полей так:
var obj = {};
obj.test = undefined;
alert( "test" in obj ); // true
alert( "blabla" in obj ); // false

//Доступ через квадратные скобки
var person = {};
person['name'] = 'Вася'; // то же что и person.name = 'Вася'
alert( "name" in person ); // true

//Доступ к свойству через переменную
var person = {};
person.age = 25;
var key = 'age';
alert( person[key] ); // выведет person['age']

//Объявление со свойствами
var menuSetup = {
    width: 300,
    height: 200,
    title: "Menu"
};
// то же самое, что:
var menuSetup = {};
menuSetup.width = 300;
menuSetup.height = 200;
menuSetup.title = 'Menu';

//Названия свойств можно перечислять в кавычках
var menuSetup = {
    width: 300,
    'height': 200,
    "мама мыла раму": true
};

//В качестве значения можно тут же указать и другой объект:
var user = {
    name: "Таня",
    age: 25,
    size: {
        top: 90,
        middle: 60,
        bottom: 90
    }
};


//--------------------Перебор свойств---------------------
//FOR IN
var menu = {
    width: 300,
    height: 200,
    title: "Menu"
};
for (var key in menu) {
    // этот код будет вызван для каждого свойства объекта
    // ..и выведет имя свойства и его значение
    alert( "Ключ: " + key + " значение: " + menu[key] );
}

//получаем кол-во свойств
alert(Object.keys(menu).length);


//--------------------Клонирование---------------------
//с помощью паттерна "Прототип"
var obj = {
    width: 300,
    height: 200,
    title: "Menu",
    clone: function () {
        return {
            width : this.width,
            height : this.height,
            title : this.title,
            clone : this.clone
        };
    }
};
obj.width = 1;
obj.height = 2;
var obj2 = obj.clone();
var obj3 = obj2.clone();
for (var key in obj3) {
    console.log( "Ключ: " + key + " значение: " + obj3[key] );
}











//---------------------------------------------------Массивы----------------------------------------------

//pop
//Удаляет последний элемент из массива и возвращает его:
var fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.pop() ); // удалили "Груша"
alert( fruits ); // Яблоко, Апельсин

//push
//Добавляет элемент в конец массива:
var fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert( fruits ); // Яблоко, Апельсин, Груша

//shift
//Удаляет из массива первый элемент и возвращает его:
var fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.shift() ); // удалили Яблоко
alert( fruits ); // Апельсин, Груша

//unshift
//Добавляет элемент в начало массива:
var fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert( fruits ); // Яблоко, Апельсин, Груша

//цикл FOR - для массивов надежнее и быстрее чем FOR IN
var arr = ["Яблоко", "Апельсин", "Груша"];
arr.name = 'name!!!';//массиву технически можно задать и любое свойство
for (var i=0; i<arr.length; i++) {
    alert( arr[i] ); // Яблоко, Апельсин, Груша
}
for (var key in arr) {
    alert( arr[key] ); // Яблоко, Апельсин, Груша, name!!!
}

//Многомерные массивы
//Массивы в JavaScript могут содержать в качестве элементов другие массивы.
//Это можно использовать для создания многомерных массивов, например матриц:
var matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
];
alert( matrix[1][1] ); // центральный элемент


//split
var names = 'Маша, Петя, Марина, Василий';
var arr = names.split(', ');
for (var i = 0; i < arr.length; i++) {
    alert( 'Вам сообщение ' + arr[i] );
}

//join
var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
var str = arr.join(';');
alert( str ); // Маша;Петя;Марина;Василий

//Удаление из массива
//Так как массивы являются объектами, то для удаления ключа можно воспользоваться обычным delete:
var arr = ["Я", "иду", "домой"];
delete arr[1]; // значение с индексом 1 удалено
// теперь arr = ["Я", undefined, "домой"];
alert( arr[1] ); // undefined


//---------------------------splice---------------------------
//Начнём с удаления:
var arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
alert( arr ); //  осталось ["Я", "JavaScript"]

//удалим 3 элемента и вставим другие на их место:
var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
// удалить 3 первых элемента и добавить другие вместо них
arr.splice(0, 3, "Мы", "изучаем");
alert( arr ); // теперь ["Мы", "изучаем", "JavaScript"]

//splice возвращает массив из удаленных элементов:
var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
// удалить 2 первых элемента
var removed = arr.splice(0, 2);
alert( removed ); // "Я", "сейчас" <-- array of removed elements

//splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0:
var arr = ["Я", "изучаю", "JavaScript"];
// с позиции 2, удалить 0, вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

//Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:
var arr = [1, 2, 5];
// начиная с позиции индексом -1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);
alert( arr ); // результат: 1,2,3,4,5


//---------------------------slice---------------------------
var arr = ["Почему", "надо", "учить", "JavaScript"];
var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)
alert( arr2 ); // надо, учить

//Если не указать end – копирование будет до конца массива:
var arr = ["Почему", "надо", "учить", "JavaScript"];
alert( arr.slice(1) ); // взять все элементы, начиная с номера 1

//Можно использовать отрицательные индексы, они отсчитываются с конца:
var arr2 = arr.slice(-2); // копировать от 2-го элемента с конца и дальше

//Если вообще не указать аргументов – скопируется весь массив:
var fullCopy = arr.slice();


//---------------------------sort()---------------------------
var arr = [ 1, 2, 15 ];
arr.sort();
//по умолчанию sort сортирует, преобразуя элементы к строке:
alert( arr );  // 1, 15, 2

//укажем эту функцию явно, отсортируем элементы массива как числа:
function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a < b) return -1;
}
var arr = [ 15, 1, 2 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15


//------------------------Object.keys()------------------------
var user = {
    name: "Петя",
    age: 30
};
var keys = Object.keys(user);// возвращает массив свойств объекта
alert( keys ); // name, age
for(var i = 0; i < keys.length; i++){
    console.log(user[keys[i]]);
}


//---------------------перебирающие методы-----------------------

//forEach
//arr.forEach(callback[, thisArg])
//для каждого элемента массива вызывает функцию callback.
var arr = ["Яблоко", "Апельсин", "Груша"];
arr.forEach(function(item, i, arr) {
    alert( i + ": " + item + " (массив:" + arr + ")" );
    //0: Яблоко (массив:Яблоко,Апельсин,Груша)
    //1: Апельсин (массив:Яблоко,Апельсин,Груша)
    //2: Груша (массив:Яблоко,Апельсин,Груша)
});

//filter
//arr.filter(callback[, thisArg])
//Он создаёт новый массив,
// в который войдут только те элементы arr,
// для которых вызов callback(item, i, arr) возвратит true.
var arr = [1, -1, 2, -2, 3];
var positiveArr = arr.filter(function(number) {
    return number > 0;
});
alert( positiveArr ); // 1,2,3

//map
//Метод «arr.map(callback[, thisArg])» используется для трансформации массива.
//Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.
var names = ['HTML', 'CSS', 'JavaScript'];
var nameLengths = names.map(function(name) {
    return name.length;
});
// получили массив с длинами
alert(nameLengths); // 4,3,10
alert(names); //HTML,CSS,JavaScript

//every/some
//Эти методы используются для проверки массива.
var arr = [1, -1, 2, -2, 3];
function isPositive(number) {
    return number > 0;
}
alert( arr.every(isPositive) ); // false, не все положительные
alert( arr.some(isPositive) ); // true, есть хоть одно положительное


//reduce/reduceRight
//Аргументы функции callback(previousValue, currentItem, index, arr):
//  previousValue – последний результат вызова функции, он же «промежуточный результат».
//  currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо.
//  index – номер текущего элемента.
//  arr – обрабатываемый массив.
//Кроме callback, методу можно передать «начальное значение» – аргумент initialValue
//Если он есть, то на первом вызове значение previousValue будет равно initialValue,
// а если у reduce нет второго аргумента,
// то оно равно первому элементу массива, а перебор начинается со второго.

//Например, в качестве «свёртки» мы хотим получить сумму всех элементов массива.
var arr = [1, 2, 3, 4, 5];
// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
var result = arr.reduce(function(sum, current) {
    return sum + current;
});
alert( result ); // 15

//Метод arr.reduceRight работает аналогично, но идёт по массиву справа-налево.
